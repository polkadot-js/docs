"use strict";(self.webpackChunkpolkadot_js=self.webpackChunkpolkadot_js||[]).push([[6253],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return g}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=l(n),g=r,b=p["".concat(c,".").concat(g)]||p[g]||u[g]||i;return n?a.createElement(b,o(o({ref:t},d),{},{components:n})):a.createElement(b,o({ref:t},d))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},5454:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return d},default:function(){return p}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],s={title:"Loading saved pairs"},c=void 0,l={unversionedId:"ui-keyring/start/loading",id:"ui-keyring/start/loading",title:"Loading saved pairs",description:"Adding accounts is good. Having access to these accounts when added via const { pair } = keyring.addUr(...) is better, but being able to access these to iterate over at a later point (even after reload), is magic. Here we will try to add some magic to your experience, allowing you to retrieve accounts as well as subscribe to changes as they happen.",source:"@site/docs/ui-keyring/start/loading.md",sourceDirName:"ui-keyring/start",slug:"/ui-keyring/start/loading",permalink:"/docs/ui-keyring/start/loading",editUrl:"https://github.com/polkadot-js/docs/edit/master/docs/ui-keyring/start/loading.md",tags:[],version:"current",frontMatter:{title:"Loading saved pairs"},sidebar:"reference",previous:{title:"Addresses",permalink:"/docs/ui-keyring/start/addresses"},next:{title:"Overview",permalink:"/docs/extension"}},d=[{value:"Loading all available",id:"loading-all-available",children:[],level:2},{value:"Subscriptions (Optional)",id:"subscriptions-optional",children:[],level:2}],u={toc:d};function p(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Adding accounts is good. Having access to these accounts when added via ",(0,i.kt)("inlineCode",{parentName:"p"},"const { pair } = keyring.addUr(...)")," is better, but being able to access these to iterate over at a later point (even after reload), is magic. Here we will try to add some magic to your experience, allowing you to retrieve accounts as well as subscribe to changes as they happen."),(0,i.kt)("h2",{id:"loading-all-available"},"Loading all available"),(0,i.kt)("p",null,"As we've seen in the keyring init section, when we can ",(0,i.kt)("inlineCode",{parentName:"p"},"loadAll"),", it loads all added added - this includes those added via ",(0,i.kt)("inlineCode",{parentName:"p"},"addUri(...)")," which transparently saves to the provided storage. Loading means it is available in the keyring, to get a list of the accounts, we can then do -"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { u8aToHex } from '@polkadot/util';\n\n...\nconst accounts = keyring.getAccounts();\n\naccounts.forEach(({ address, meta, publicKey }) =>\n  console.log(address, JSON.stringify(meta), u8aToHex(publicKey))\n);\n")),(0,i.kt)("p",null,"The above interface was probably not quite what you have been expecting, rather you would have expected to get back a list of the pairs, but rather you received a list of the account descriptors. Some rationale for this approach - since we have ",(0,i.kt)("inlineCode",{parentName:"p"},"getAccounts()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"getAddresses()")," (for contacts) and ",(0,i.kt)("inlineCode",{parentName:"p"},"getContracts()")," the consistent interface here is applicable. Instead based on an address, you can then retrieve a specific pair -"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"accounts.forEach(({ address }) => {\n  // retrieve via address or publicKey\n  const pair = getPair(address);\n\n  // display the locked account status\n  console.log(address, pair.isLocked);\n});\n")),(0,i.kt)("p",null,"Similarly we have a ",(0,i.kt)("inlineCode",{parentName:"p"},"getPairs()")," that mirrors ",(0,i.kt)("inlineCode",{parentName:"p"},"getAccounts()"),", but retrieves the list of available pairs - which is the output you probably expected from the initial ",(0,i.kt)("inlineCode",{parentName:"p"},"getAccounts()")," call."),(0,i.kt)("h2",{id:"subscriptions-optional"},"Subscriptions (Optional)"),(0,i.kt)("p",null,"In addition to the retrieving of accounts on demand, we can actually subscribe to accounts for the keyring. This subscription returns a list of all accounts as they are updated, i.e. when a new account is added it will callback with a list of all the account, including the new one, when an account is removed, it will callback with a list of accounts, excluding the removed member."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"...\n// create a subscription to all available accounts, updated real-time\nconst sub = keyring.accounts.subject.subscribe((accounts) => {\n  accounts.forEach(({ json, option }) =>\n    // json is the stored data, including address\n    // option is a { name: meta.name, value: address }\n  );\n});\n\n...\n// at some point  when we are not interested anymore, we can unsubscribe\nsub.unsubscribe();\n")),(0,i.kt)("p",null,"As with the ",(0,i.kt)("inlineCode",{parentName:"p"},"get{Accounts|Addresses|Contracts}()")," functions, similarly we have in addition to ",(0,i.kt)("inlineCode",{parentName:"p"},"keyring.accounts.subject")," the ",(0,i.kt)("inlineCode",{parentName:"p"},"keyring.addresses.subject")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"keyring.contracts.subject")," subscriptions available, with the same generic result set."))}p.isMDXComponent=!0}}]);