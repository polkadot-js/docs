"use strict";(self.webpackChunkpolkadot_js=self.webpackChunkpolkadot_js||[]).push([[2547],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return g}});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=c(n),g=i,m=d["".concat(l,".").concat(g)]||d[g]||p[g]||a;return n?r.createElement(m,s(s({ref:t},u),{},{components:n})):r.createElement(m,s({ref:t},u))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,s=new Array(a);s[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var c=2;c<a;c++)s[c]=n[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9569:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return u},default:function(){return d}});var r=n(7462),i=n(3366),a=(n(7294),n(3905)),s=["components"],o={title:"Sign & Verify"},l=void 0,c={unversionedId:"keyring/start/sign-verify",id:"keyring/start/sign-verify",title:"Sign & Verify",description:"In the previous sections we explored creating and adding a pair to the Keyring. However, let's actually use the pairs in something that is not just extracting local information.",source:"@site/docs/keyring/start/sign-verify.md",sourceDirName:"keyring/start",slug:"/keyring/start/sign-verify",permalink:"/docs/keyring/start/sign-verify",editUrl:"https://github.com/polkadot-js/docs/edit/master/docs/keyring/start/sign-verify.md",tags:[],version:"current",frontMatter:{title:"Sign & Verify"},sidebar:"reference",previous:{title:"ss58 Formats",permalink:"/docs/keyring/start/ss58"},next:{title:"Substrate Uri",permalink:"/docs/keyring/start/suri"}},u=[{value:"Using known pairs",id:"using-known-pairs",children:[],level:2},{value:"Verify using address or publicKey",id:"verify-using-address-or-publickey",children:[],level:2},{value:"Substrate Uri",id:"substrate-uri",children:[],level:2}],p={toc:u};function d(e){var t=e.components,n=(0,i.Z)(e,s);return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"In the previous sections we explored creating and adding a pair to the Keyring. However, let's actually use the pairs in something that is not just extracting local information."),(0,a.kt)("p",null,"When using the API, pairs are critical since it gets used in ",(0,a.kt)("a",{parentName:"p",href:"/docs/api/start/api.tx.subs#transaction-inclusion"},"signing transactions"),". The same signing and verification structure can be used on any kind of message. Here we will take you through the steps of signing and verifying messages."),(0,a.kt)("h2",{id:"using-known-pairs"},"Using known pairs"),(0,a.kt)("p",null,"Assuming a known pair ",(0,a.kt)("inlineCode",{parentName:"p"},"Alice")," we can exchange signatures and perform verification."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"import { stringToU8a, u8aToHex } from '@polkadot/util';\n\n// create Alice based on the development seed\nconst alice = keyring.addFromUri('//Alice');\n\n// create the message, actual signature and verify\nconst message = stringToU8a('this is our message');\nconst signature = alice.sign(message);\nconst isValid = alice.verify(message, signature);\n\n// output the result\nconsole.log(`${u8aToHex(signature)} is ${isValid ? 'valid' : 'invalid'}`);\n")),(0,a.kt)("p",null,"Here we created an ",(0,a.kt)("inlineCode",{parentName:"p"},"Alice")," pair with a ",(0,a.kt)("a",{parentName:"p",href:"/docs/keyring/start/suri"},"derivation path"),". In the next section we will delve into derivation, but for now just know that we have used the Substrate development mnemonic (default when no mnemonic supplied, but a derivation is) and created an address from it. Next we signed the message and then verified it."),(0,a.kt)("p",null,"On the line logging, you will notice a difference between ",(0,a.kt)("inlineCode",{parentName:"p"},"sr25519")," pairs compared to other crypto types such as ",(0,a.kt)("inlineCode",{parentName:"p"},"ed25519"),". In ",(0,a.kt)("inlineCode",{parentName:"p"},"sr25519")," signatures are non-deterministic. This means that each time a signature is generated, like above, even if the data does match, the signature will be different. In the case of ",(0,a.kt)("inlineCode",{parentName:"p"},"ed25519")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"ecdsa")," each signature, for the same input data, will be the same."),(0,a.kt)("h2",{id:"verify-using-address-or-publickey"},"Verify using address or publicKey"),(0,a.kt)("p",null,"In the previous example it is assumed that you have access to the pair to verify. In real-world examples this is rarely the case since the pair owner won't share his secrets with the person verifying the signature. So while the person generating the signature needs access to the pair (since the signature is generated via the wrapped ",(0,a.kt)("inlineCode",{parentName:"p"},"secretKey"),"), the process verifying the signature would only have access to the address."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"import { stringToU8a, u8aToHex } from '@polkadot/util';\nimport { signatureVerify } from '@polkadot/util-crypto';\n\n// create Alice based on the development seed\nconst alice = keyring.addFromUri('//Alice');\n\n// create the message and sign it\nconst message = stringToU8a('this is our message');\nconst signature = alice.sign(message);\n\n// verify the message using Alice's address\nconst { isValid } = signatureVerify(message, signature, alice.address);\n\n// output the result\nconsole.log(`${u8aToHex(signature)} is ${isValid ? 'valid' : 'invalid'}`);\n")),(0,a.kt)("h2",{id:"substrate-uri"},"Substrate Uri"),(0,a.kt)("p",null,"We understand how to use the keyring to perform basic operations, next up we will dive into the ",(0,a.kt)("a",{parentName:"p",href:"/docs/keyring/start/suri"},"Substrate derivation")," as briefly introduced with the ",(0,a.kt)("inlineCode",{parentName:"p"},"Alice")," keypair above."))}d.isMDXComponent=!0}}]);