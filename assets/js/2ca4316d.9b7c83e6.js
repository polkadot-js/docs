"use strict";(self.webpackChunkpolkadot_js=self.webpackChunkpolkadot_js||[]).push([[6916],{4137:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return k}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=p(n),d=a,k=c["".concat(s,".").concat(d)]||c[d]||m[d]||o;return n?i.createElement(k,r(r({ref:t},u),{},{components:n})):i.createElement(k,r({ref:t},u))}));function k(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:a,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8712:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return s},default:function(){return k},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return c}});var i=n(7462),a=n(3366),o=(n(7294),n(4137)),r=["components"],l={title:"Runtime"},s=void 0,p={unversionedId:"substrate/runtime",id:"substrate/runtime",title:"Runtime",description:"The following section contains known runtime calls that may be available on specific runtimes (depending on configuration and available pallets). These call directly into the WASM runtime for queries and operations.",source:"@site/docs/substrate/runtime.md",sourceDirName:"substrate",slug:"/substrate/runtime",permalink:"/docs/substrate/runtime",draft:!1,editUrl:"https://github.com/polkadot-js/docs/edit/master/docs/substrate/runtime.md",tags:[],version:"current",frontMatter:{title:"Runtime"},sidebar:"reference",previous:{title:"Overview",permalink:"/docs/substrate"},next:{title:"JSON-RPC",permalink:"/docs/substrate/rpc"}},u={},c=[{value:"accountNonceApi",id:"accountnonceapi",level:2},{value:"accountNonce(account: <code>SpCoreCryptoAccountId32</code>): <code>u32</code>",id:"accountnonceaccount-spcorecryptoaccountid32-u32",level:3},{value:"assetConversionApi",id:"assetconversionapi",level:2},{value:"getReserves(asset1: <code>FrameSupportTokensFungibleUnionOfNativeOrWithId</code>, asset2: <code>FrameSupportTokensFungibleUnionOfNativeOrWithId</code>): <code>Option&lt;(u128,u128)&gt;</code>",id:"getreservesasset1-framesupporttokensfungibleunionofnativeorwithid-asset2-framesupporttokensfungibleunionofnativeorwithid-optionu128u128",level:3},{value:"quotePriceExactTokensForTokens(asset1: <code>FrameSupportTokensFungibleUnionOfNativeOrWithId</code>, asset2: <code>FrameSupportTokensFungibleUnionOfNativeOrWithId</code>, amount: <code>u128</code>, include_fee: <code>bool</code>): <code>Option&lt;u128&gt;</code>",id:"quotepriceexacttokensfortokensasset1-framesupporttokensfungibleunionofnativeorwithid-asset2-framesupporttokensfungibleunionofnativeorwithid-amount-u128-include_fee-bool-optionu128",level:3},{value:"quotePriceTokensForExactTokens(asset1: <code>FrameSupportTokensFungibleUnionOfNativeOrWithId</code>, asset2: <code>FrameSupportTokensFungibleUnionOfNativeOrWithId</code>, amount: <code>u128</code>, include_fee: <code>bool</code>): <code>Option&lt;u128&gt;</code>",id:"quotepricetokensforexacttokensasset1-framesupporttokensfungibleunionofnativeorwithid-asset2-framesupporttokensfungibleunionofnativeorwithid-amount-u128-include_fee-bool-optionu128",level:3},{value:"assetsApi",id:"assetsapi",level:2},{value:"accountBalances(account: <code>SpCoreCryptoAccountId32</code>): <code>Vec&lt;(u32,u128)&gt;</code>",id:"accountbalancesaccount-spcorecryptoaccountid32-vecu32u128",level:3},{value:"authorityDiscoveryApi",id:"authoritydiscoveryapi",level:2},{value:"authorities(): <code>Vec&lt;SpAuthorityDiscoveryAppPublic&gt;</code>",id:"authorities-vecspauthoritydiscoveryapppublic",level:3},{value:"babeApi",id:"babeapi",level:2},{value:"configuration(): <code>SpConsensusBabeBabeConfiguration</code>",id:"configuration-spconsensusbabebabeconfiguration",level:3},{value:"currentEpoch(): <code>SpConsensusBabeEpoch</code>",id:"currentepoch-spconsensusbabeepoch",level:3},{value:"currentEpochStart(): <code>SpConsensusSlotsSlot</code>",id:"currentepochstart-spconsensusslotsslot",level:3},{value:"generateKeyOwnershipProof(slot: <code>SpConsensusSlotsSlot</code>, authority_id: <code>SpConsensusBabeAppPublic</code>): <code>Option&lt;Bytes&gt;</code>",id:"generatekeyownershipproofslot-spconsensusslotsslot-authority_id-spconsensusbabeapppublic-optionbytes",level:3},{value:"nextEpoch(): <code>SpConsensusBabeEpoch</code>",id:"nextepoch-spconsensusbabeepoch",level:3},{value:"submitReportEquivocationUnsignedExtrinsic(equivocation_proof: <code>SpConsensusSlotsEquivocationProof</code>, key_owner_proof: <code>SpConsensusBabeOpaqueKeyOwnershipProof</code>): <code>Option&lt;Null&gt;</code>",id:"submitreportequivocationunsignedextrinsicequivocation_proof-spconsensusslotsequivocationproof-key_owner_proof-spconsensusbabeopaquekeyownershipproof-optionnull",level:3},{value:"beefyApi",id:"beefyapi",level:2},{value:"beefyGenesis(): <code>Option&lt;u32&gt;</code>",id:"beefygenesis-optionu32",level:3},{value:"generateAncestryProof(prev_block_number: <code>u32</code>, best_known_block_number: <code>Option&lt;u32&gt;</code>): <code>Option&lt;Bytes&gt;</code>",id:"generateancestryproofprev_block_number-u32-best_known_block_number-optionu32-optionbytes",level:3},{value:"generateKeyOwnershipProof(set_id: <code>u64</code>, authority_id: <code>SpConsensusBeefyEcdsaCryptoPublic</code>): <code>Option&lt;Bytes&gt;</code>",id:"generatekeyownershipproofset_id-u64-authority_id-spconsensusbeefyecdsacryptopublic-optionbytes",level:3},{value:"submitReportDoubleVotingUnsignedExtrinsic(equivocation_proof: <code>SpConsensusBeefyDoubleVotingProof</code>, key_owner_proof: <code>SpRuntimeOpaqueValue</code>): <code>Option&lt;Null&gt;</code>",id:"submitreportdoublevotingunsignedextrinsicequivocation_proof-spconsensusbeefydoublevotingproof-key_owner_proof-spruntimeopaquevalue-optionnull",level:3},{value:"submitReportForkVotingUnsignedExtrinsic(equivocation_proof: <code>SpConsensusBeefyForkVotingProofOpaqueValue</code>, key_owner_proof: <code>SpRuntimeOpaqueValue</code>): <code>Option&lt;Null&gt;</code>",id:"submitreportforkvotingunsignedextrinsicequivocation_proof-spconsensusbeefyforkvotingproofopaquevalue-key_owner_proof-spruntimeopaquevalue-optionnull",level:3},{value:"submitReportFutureBlockVotingUnsignedExtrinsic(equivocation_proof: <code>SpConsensusBeefyFutureBlockVotingProof</code>, key_owner_proof: <code>SpRuntimeOpaqueValue</code>): <code>Option&lt;Null&gt;</code>",id:"submitreportfutureblockvotingunsignedextrinsicequivocation_proof-spconsensusbeefyfutureblockvotingproof-key_owner_proof-spruntimeopaquevalue-optionnull",level:3},{value:"validatorSet(): <code>Option&lt;SpConsensusBeefyValidatorSet&gt;</code>",id:"validatorset-optionspconsensusbeefyvalidatorset",level:3},{value:"blockBuilder",id:"blockbuilder",level:2},{value:"applyExtrinsic(extrinsic: <code>SpRuntimeUncheckedExtrinsic</code>): <code>Result&lt;Result&lt;Null, SpRuntimeDispatchError&gt;, SpRuntimeTransactionValidityTransactionValidityError&gt;</code>",id:"applyextrinsicextrinsic-spruntimeuncheckedextrinsic-resultresultnull-spruntimedispatcherror-spruntimetransactionvaliditytransactionvalidityerror",level:3},{value:"checkInherents(block: <code>SpRuntimeBlock</code>, data: <code>SpInherentsInherentData</code>): <code>SpInherentsCheckInherentsResult</code>",id:"checkinherentsblock-spruntimeblock-data-spinherentsinherentdata-spinherentscheckinherentsresult",level:3},{value:"finalizeBlock(): <code>SpRuntimeHeader</code>",id:"finalizeblock-spruntimeheader",level:3},{value:"inherentExtrinsics(inherent: <code>SpInherentsInherentData</code>): <code>Vec&lt;Bytes&gt;</code>",id:"inherentextrinsicsinherent-spinherentsinherentdata-vecbytes",level:3},{value:"contractsApi",id:"contractsapi",level:2},{value:"call(origin: <code>SpCoreCryptoAccountId32</code>, dest: <code>SpCoreCryptoAccountId32</code>, value: <code>u128</code>, gas_limit: <code>Option&lt;SpWeightsWeightV2Weight&gt;</code>, storage_deposit_limit: <code>Option&lt;u128&gt;</code>, input_data: <code>Bytes</code>): <code>{&quot;gasConsumed&quot;:&quot;SpWeightsWeightV2Weight&quot;,&quot;gasRequired&quot;:&quot;SpWeightsWeightV2Weight&quot;,&quot;storageDeposit&quot;:&quot;PalletContractsPrimitivesStorageDeposit&quot;,&quot;debugMessage&quot;:&quot;Bytes&quot;,&quot;result&quot;:&quot;Result&lt;PalletContractsPrimitivesExecReturnValue, SpRuntimeDispatchError&gt;&quot;,&quot;events&quot;:&quot;Option&lt;Vec&lt;FrameSystemEventRecord&gt;&gt;&quot;}</code>",id:"callorigin-spcorecryptoaccountid32-dest-spcorecryptoaccountid32-value-u128-gas_limit-optionspweightsweightv2weight-storage_deposit_limit-optionu128-input_data-bytes-gasconsumedspweightsweightv2weightgasrequiredspweightsweightv2weightstoragedepositpalletcontractsprimitivesstoragedepositdebugmessagebytesresultresultpalletcontractsprimitivesexecreturnvalue-spruntimedispatcherroreventsoptionvecframesystemeventrecord",level:3},{value:"getStorage(address: <code>SpCoreCryptoAccountId32</code>, key: <code>Bytes</code>): <code>Result&lt;Option&lt;Bytes&gt;, PalletContractsPrimitivesContractAccessError&gt;</code>",id:"getstorageaddress-spcorecryptoaccountid32-key-bytes-resultoptionbytes-palletcontractsprimitivescontractaccesserror",level:3},{value:"instantiate(origin: <code>SpCoreCryptoAccountId32</code>, value: <code>u128</code>, gas_limit: <code>Option&lt;SpWeightsWeightV2Weight&gt;</code>, storage_deposit_limit: <code>Option&lt;u128&gt;</code>, code: <code>PalletContractsPrimitivesCode</code>, data: <code>Bytes</code>, salt: <code>Bytes</code>): <code>PalletContractsPrimitivesContractResult</code>",id:"instantiateorigin-spcorecryptoaccountid32-value-u128-gas_limit-optionspweightsweightv2weight-storage_deposit_limit-optionu128-code-palletcontractsprimitivescode-data-bytes-salt-bytes-palletcontractsprimitivescontractresult",level:3},{value:"uploadCode(origin: <code>SpCoreCryptoAccountId32</code>, code: <code>Bytes</code>, storage_deposit_limit: <code>Option&lt;u128&gt;</code>, determinism: <code>PalletContractsWasmDeterminism</code>): <code>Result&lt;PalletContractsPrimitivesCodeUploadReturnValue, SpRuntimeDispatchError&gt;</code>",id:"uploadcodeorigin-spcorecryptoaccountid32-code-bytes-storage_deposit_limit-optionu128-determinism-palletcontractswasmdeterminism-resultpalletcontractsprimitivescodeuploadreturnvalue-spruntimedispatcherror",level:3},{value:"core",id:"core",level:2},{value:"executeBlock(block: <code>SpRuntimeBlock</code>): <code>Null</code>",id:"executeblockblock-spruntimeblock-null",level:3},{value:"initializeBlock(header: <code>SpRuntimeHeader</code>): <code>SpRuntimeExtrinsicInclusionMode</code>",id:"initializeblockheader-spruntimeheader-spruntimeextrinsicinclusionmode",level:3},{value:"version(): <code>SpVersionRuntimeVersion</code>",id:"version-spversionruntimeversion",level:3},{value:"genesisBuilder",id:"genesisbuilder",level:2},{value:"buildState(json: <code>Bytes</code>): <code>Result&lt;Null, Text&gt;</code>",id:"buildstatejson-bytes-resultnull-text",level:3},{value:"getPreset(id: <code>Option&lt;Text&gt;</code>): <code>Option&lt;Bytes&gt;</code>",id:"getpresetid-optiontext-optionbytes",level:3},{value:"presetNames(): <code>Vec&lt;Text&gt;</code>",id:"presetnames-vectext",level:3},{value:"grandpaApi",id:"grandpaapi",level:2},{value:"currentSetId(): <code>u64</code>",id:"currentsetid-u64",level:3},{value:"generateKeyOwnershipProof(set_id: <code>u64</code>, authority_id: <code>SpConsensusGrandpaAppPublic</code>): <code>Option&lt;Bytes&gt;</code>",id:"generatekeyownershipproofset_id-u64-authority_id-spconsensusgrandpaapppublic-optionbytes",level:3},{value:"grandpaAuthorities(): <code>Vec&lt;(SpConsensusGrandpaAppPublic,u64)&gt;</code>",id:"grandpaauthorities-vecspconsensusgrandpaapppublicu64",level:3},{value:"submitReportEquivocationUnsignedExtrinsic(equivocation_proof: <code>SpConsensusGrandpaEquivocationProof</code>, key_owner_proof: <code>SpRuntimeOpaqueValue</code>): <code>Option&lt;Null&gt;</code>",id:"submitreportequivocationunsignedextrinsicequivocation_proof-spconsensusgrandpaequivocationproof-key_owner_proof-spruntimeopaquevalue-optionnull",level:3},{value:"metadata",id:"metadata",level:2},{value:"metadata(): <code>SpCoreOpaqueMetadata</code>",id:"metadata-spcoreopaquemetadata",level:3},{value:"metadataAtVersion(version: <code>u32</code>): <code>Option&lt;OpaqueMetadata&gt;</code>",id:"metadataatversionversion-u32-optionopaquemetadata",level:3},{value:"metadataVersions(): <code>Vec&lt;u32&gt;</code>",id:"metadataversions-vecu32",level:3},{value:"mixnetApi",id:"mixnetapi",level:2},{value:"currentMixnodes(): <code>Result&lt;Vec&lt;SpMixnetMixnode&gt;, SpMixnetMixnodesErr&gt;</code>",id:"currentmixnodes-resultvecspmixnetmixnode-spmixnetmixnodeserr",level:3},{value:"maybeRegister(session_index: <code>u32</code>, mixnode: <code>SpMixnetMixnode</code>): <code>bool</code>",id:"mayberegistersession_index-u32-mixnode-spmixnetmixnode-bool",level:3},{value:"prevMixnodes(): <code>Result&lt;Vec&lt;SpMixnetMixnode&gt;, SpMixnetMixnodesErr&gt;</code>",id:"prevmixnodes-resultvecspmixnetmixnode-spmixnetmixnodeserr",level:3},{value:"sessionStatus(): <code>SpMixnetSessionStatus</code>",id:"sessionstatus-spmixnetsessionstatus",level:3},{value:"mmrApi",id:"mmrapi",level:2},{value:"generateProof(block_numbers: <code>Vec&lt;u32&gt;</code>, best_known_block_number: <code>Option&lt;u32&gt;</code>): <code>Result&lt;(Vec&lt;Bytes&gt;,SpMmrPrimitivesLeafProof), SpMmrPrimitivesError&gt;</code>",id:"generateproofblock_numbers-vecu32-best_known_block_number-optionu32-resultvecbytesspmmrprimitivesleafproof-spmmrprimitiveserror",level:3},{value:"mmrLeafCount(): <code>Result&lt;u64, SpMmrPrimitivesError&gt;</code>",id:"mmrleafcount-resultu64-spmmrprimitiveserror",level:3},{value:"mmrRoot(): <code>Result&lt;H256, SpMmrPrimitivesError&gt;</code>",id:"mmrroot-resulth256-spmmrprimitiveserror",level:3},{value:"verifyProof(leaves: <code>Vec&lt;Bytes&gt;</code>, proof: <code>SpMmrPrimitivesLeafProof</code>): <code>Result&lt;Null, SpMmrPrimitivesError&gt;</code>",id:"verifyproofleaves-vecbytes-proof-spmmrprimitivesleafproof-resultnull-spmmrprimitiveserror",level:3},{value:"verifyProofStateless(root: <code>PrimitiveTypesH256</code>, leaves: <code>Vec&lt;Bytes&gt;</code>, proof: <code>SpMmrPrimitivesLeafProof</code>): <code>Result&lt;Null, SpMmrPrimitivesError&gt;</code>",id:"verifyproofstatelessroot-primitivetypesh256-leaves-vecbytes-proof-spmmrprimitivesleafproof-resultnull-spmmrprimitiveserror",level:3},{value:"nftsApi",id:"nftsapi",level:2},{value:"attribute(collection: <code>u32</code>, item: <code>u32</code>, key: <code>Bytes</code>): <code>Option&lt;Bytes&gt;</code>",id:"attributecollection-u32-item-u32-key-bytes-optionbytes",level:3},{value:"collectionAttribute(collection: <code>u32</code>, key: <code>Bytes</code>): <code>Option&lt;Bytes&gt;</code>",id:"collectionattributecollection-u32-key-bytes-optionbytes",level:3},{value:"collectionOwner(collection: <code>u32</code>): <code>Option&lt;AccountId32&gt;</code>",id:"collectionownercollection-u32-optionaccountid32",level:3},{value:"customAttribute(account: <code>SpCoreCryptoAccountId32</code>, collection: <code>u32</code>, item: <code>u32</code>, key: <code>Bytes</code>): <code>Option&lt;Bytes&gt;</code>",id:"customattributeaccount-spcorecryptoaccountid32-collection-u32-item-u32-key-bytes-optionbytes",level:3},{value:"owner(collection: <code>u32</code>, item: <code>u32</code>): <code>Option&lt;AccountId32&gt;</code>",id:"ownercollection-u32-item-u32-optionaccountid32",level:3},{value:"systemAttribute(collection: <code>u32</code>, item: <code>Option&lt;u32&gt;</code>, key: <code>Bytes</code>): <code>Option&lt;Bytes&gt;</code>",id:"systemattributecollection-u32-item-optionu32-key-bytes-optionbytes",level:3},{value:"nominationPoolsApi",id:"nominationpoolsapi",level:2},{value:"balanceToPoints(pool_id: <code>u32</code>, new_funds: <code>u128</code>): <code>u128</code>",id:"balancetopointspool_id-u32-new_funds-u128-u128",level:3},{value:"memberNeedsDelegateMigration(member: <code>SpCoreCryptoAccountId32</code>): <code>bool</code>",id:"memberneedsdelegatemigrationmember-spcorecryptoaccountid32-bool",level:3},{value:"memberPendingSlash(member: <code>SpCoreCryptoAccountId32</code>): <code>u128</code>",id:"memberpendingslashmember-spcorecryptoaccountid32-u128",level:3},{value:"memberTotalBalance(who: <code>SpCoreCryptoAccountId32</code>): <code>u128</code>",id:"membertotalbalancewho-spcorecryptoaccountid32-u128",level:3},{value:"pendingRewards(who: <code>SpCoreCryptoAccountId32</code>): <code>u128</code>",id:"pendingrewardswho-spcorecryptoaccountid32-u128",level:3},{value:"pointsToBalance(pool_id: <code>u32</code>, points: <code>u128</code>): <code>u128</code>",id:"pointstobalancepool_id-u32-points-u128-u128",level:3},{value:"poolAccounts(pool_id: <code>u32</code>): <code>(AccountId32,AccountId32)</code>",id:"poolaccountspool_id-u32-accountid32accountid32",level:3},{value:"poolBalance(pool_id: <code>u32</code>): <code>u128</code>",id:"poolbalancepool_id-u32-u128",level:3},{value:"poolNeedsDelegateMigration(pool_id: <code>u32</code>): <code>bool</code>",id:"poolneedsdelegatemigrationpool_id-u32-bool",level:3},{value:"poolPendingSlash(pool_id: <code>u32</code>): <code>u128</code>",id:"poolpendingslashpool_id-u32-u128",level:3},{value:"offchainWorkerApi",id:"offchainworkerapi",level:2},{value:"offchainWorker(header: <code>SpRuntimeHeader</code>): <code>Null</code>",id:"offchainworkerheader-spruntimeheader-null",level:3},{value:"reviveApi",id:"reviveapi",level:2},{value:"balance(address: <code>PrimitiveTypesH160</code>): <code>u128</code>",id:"balanceaddress-primitivetypesh160-u128",level:3},{value:"call(origin: <code>SpCoreCryptoAccountId32</code>, dest: <code>PrimitiveTypesH160</code>, value: <code>u128</code>, gas_limit: <code>Option&lt;SpWeightsWeightV2Weight&gt;</code>, storage_deposit_limit: <code>Option&lt;u128&gt;</code>, input_data: <code>Bytes</code>): <code>PalletRevivePrimitivesContractResultExecReturnValue</code>",id:"callorigin-spcorecryptoaccountid32-dest-primitivetypesh160-value-u128-gas_limit-optionspweightsweightv2weight-storage_deposit_limit-optionu128-input_data-bytes-palletreviveprimitivescontractresultexecreturnvalue",level:3},{value:"ethTransact(origin: <code>PrimitiveTypesH160</code>, dest: <code>Option&lt;H160&gt;</code>, value: <code>u128</code>, input: <code>Bytes</code>, gas_limit: <code>Option&lt;SpWeightsWeightV2Weight&gt;</code>, storage_deposit_limit: <code>Option&lt;u128&gt;</code>): <code>PalletRevivePrimitivesEthContractResult</code>",id:"ethtransactorigin-primitivetypesh160-dest-optionh160-value-u128-input-bytes-gas_limit-optionspweightsweightv2weight-storage_deposit_limit-optionu128-palletreviveprimitivesethcontractresult",level:3},{value:"getStorage(address: <code>PrimitiveTypesH160</code>, key: <code>[u8;32]</code>): <code>Result&lt;Option&lt;Bytes&gt;, PalletRevivePrimitivesContractAccessError&gt;</code>",id:"getstorageaddress-primitivetypesh160-key-u832-resultoptionbytes-palletreviveprimitivescontractaccesserror",level:3},{value:"instantiate(origin: <code>SpCoreCryptoAccountId32</code>, value: <code>u128</code>, gas_limit: <code>Option&lt;SpWeightsWeightV2Weight&gt;</code>, storage_deposit_limit: <code>Option&lt;u128&gt;</code>, code: <code>PalletRevivePrimitivesCode</code>, data: <code>Bytes</code>, salt: <code>Option&lt;[u8;32]&gt;</code>): <code>PalletRevivePrimitivesContractResultInstantiateReturnValue</code>",id:"instantiateorigin-spcorecryptoaccountid32-value-u128-gas_limit-optionspweightsweightv2weight-storage_deposit_limit-optionu128-code-palletreviveprimitivescode-data-bytes-salt-optionu832-palletreviveprimitivescontractresultinstantiatereturnvalue",level:3},{value:"nonce(address: <code>PrimitiveTypesH160</code>): <code>u32</code>",id:"nonceaddress-primitivetypesh160-u32",level:3},{value:"uploadCode(origin: <code>SpCoreCryptoAccountId32</code>, code: <code>Bytes</code>, storage_deposit_limit: <code>Option&lt;u128&gt;</code>): <code>Result&lt;PalletRevivePrimitivesCodeUploadReturnValue, SpRuntimeDispatchError&gt;</code>",id:"uploadcodeorigin-spcorecryptoaccountid32-code-bytes-storage_deposit_limit-optionu128-resultpalletreviveprimitivescodeuploadreturnvalue-spruntimedispatcherror",level:3},{value:"sessionKeys",id:"sessionkeys",level:2},{value:"decodeSessionKeys(encoded: <code>Bytes</code>): <code>Option&lt;Vec&lt;(Bytes,SpCoreCryptoKeyTypeId)&gt;&gt;</code>",id:"decodesessionkeysencoded-bytes-optionvecbytesspcorecryptokeytypeid",level:3},{value:"generateSessionKeys(seed: <code>Option&lt;Bytes&gt;</code>): <code>Bytes</code>",id:"generatesessionkeysseed-optionbytes-bytes",level:3},{value:"stakingApi",id:"stakingapi",level:2},{value:"erasStakersPageCount(era: <code>u32</code>, account: <code>SpCoreCryptoAccountId32</code>): <code>u32</code>",id:"erasstakerspagecountera-u32-account-spcorecryptoaccountid32-u32",level:3},{value:"nominationsQuota(balance: <code>u128</code>): <code>u32</code>",id:"nominationsquotabalance-u128-u32",level:3},{value:"pendingRewards(era: <code>u32</code>, account: <code>SpCoreCryptoAccountId32</code>): <code>bool</code>",id:"pendingrewardsera-u32-account-spcorecryptoaccountid32-bool",level:3},{value:"taggedTransactionQueue",id:"taggedtransactionqueue",level:2},{value:"validateTransaction(source: <code>SpRuntimeTransactionValidityTransactionSource</code>, tx: <code>SpRuntimeUncheckedExtrinsic</code>, block_hash: <code>PrimitiveTypesH256</code>): <code>Result&lt;SpRuntimeTransactionValidityValidTransaction, SpRuntimeTransactionValidityTransactionValidityError&gt;</code>",id:"validatetransactionsource-spruntimetransactionvaliditytransactionsource-tx-spruntimeuncheckedextrinsic-block_hash-primitivetypesh256-resultspruntimetransactionvalidityvalidtransaction-spruntimetransactionvaliditytransactionvalidityerror",level:3},{value:"transactionPaymentApi",id:"transactionpaymentapi",level:2},{value:"queryFeeDetails(uxt: <code>SpRuntimeUncheckedExtrinsic</code>, len: <code>u32</code>): <code>PalletTransactionPaymentFeeDetails</code>",id:"queryfeedetailsuxt-spruntimeuncheckedextrinsic-len-u32-pallettransactionpaymentfeedetails",level:3},{value:"queryInfo(uxt: <code>SpRuntimeUncheckedExtrinsic</code>, len: <code>u32</code>): <code>PalletTransactionPaymentRuntimeDispatchInfo</code>",id:"queryinfouxt-spruntimeuncheckedextrinsic-len-u32-pallettransactionpaymentruntimedispatchinfo",level:3},{value:"queryLengthToFee(length: <code>u32</code>): <code>u128</code>",id:"querylengthtofeelength-u32-u128",level:3},{value:"queryWeightToFee(weight: <code>SpWeightsWeightV2Weight</code>): <code>u128</code>",id:"queryweighttofeeweight-spweightsweightv2weight-u128",level:3},{value:"transactionPaymentCallApi",id:"transactionpaymentcallapi",level:2},{value:"queryCallFeeDetails(call: <code>KitchensinkRuntimeRuntimeCall</code>, len: <code>u32</code>): <code>PalletTransactionPaymentFeeDetails</code>",id:"querycallfeedetailscall-kitchensinkruntimeruntimecall-len-u32-pallettransactionpaymentfeedetails",level:3},{value:"queryCallInfo(call: <code>KitchensinkRuntimeRuntimeCall</code>, len: <code>u32</code>): <code>PalletTransactionPaymentRuntimeDispatchInfo</code>",id:"querycallinfocall-kitchensinkruntimeruntimecall-len-u32-pallettransactionpaymentruntimedispatchinfo",level:3},{value:"queryLengthToFee(length: <code>u32</code>): <code>u128</code>",id:"querylengthtofeelength-u32-u128-1",level:3},{value:"queryWeightToFee(weight: <code>SpWeightsWeightV2Weight</code>): <code>u128</code>",id:"queryweighttofeeweight-spweightsweightv2weight-u128-1",level:3},{value:"validateStatement",id:"validatestatement",level:2},{value:"validateStatement(source: <code>SpStatementStoreRuntimeApiStatementSource</code>, statement: <code>SpStatementStoreStatement</code>): <code>Result&lt;SpStatementStoreRuntimeApiValidStatement, SpStatementStoreRuntimeApiInvalidStatement&gt;</code>",id:"validatestatementsource-spstatementstoreruntimeapistatementsource-statement-spstatementstorestatement-resultspstatementstoreruntimeapivalidstatement-spstatementstoreruntimeapiinvalidstatement",level:3}],m={toc:c},d="wrapper";function k(e){var t=e.components,n=(0,a.Z)(e,r);return(0,o.kt)(d,(0,i.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The following section contains known runtime calls that may be available on specific runtimes (depending on configuration and available pallets). These call directly into the WASM runtime for queries and operations."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#accountnonceapi"},"accountNonceApi")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#assetconversionapi"},"assetConversionApi")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#assetsapi"},"assetsApi")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#authoritydiscoveryapi"},"authorityDiscoveryApi")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#babeapi"},"babeApi")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#beefyapi"},"beefyApi")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#blockbuilder"},"blockBuilder")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#contractsapi"},"contractsApi")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#core"},"core")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#genesisbuilder"},"genesisBuilder")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#grandpaapi"},"grandpaApi")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#metadata"},"metadata")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#mixnetapi"},"mixnetApi")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#mmrapi"},"mmrApi")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#nftsapi"},"nftsApi")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#nominationpoolsapi"},"nominationPoolsApi")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#offchainworkerapi"},"offchainWorkerApi")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#reviveapi"},"reviveApi")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#sessionkeys"},"sessionKeys")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#stakingapi"},"stakingApi")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#taggedtransactionqueue"},"taggedTransactionQueue")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#transactionpaymentapi"},"transactionPaymentApi")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#transactionpaymentcallapi"},"transactionPaymentCallApi")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"#validatestatement"},"validateStatement"))))),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"accountnonceapi"},"accountNonceApi"),(0,o.kt)("h3",{id:"accountnonceaccount-spcorecryptoaccountid32-u32"},"accountNonce(account: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpCoreCryptoAccountId32"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.accountNonceApi.accountNonce")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"accountNonceApi_account_nonce")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Get current account nonce of given ",(0,o.kt)("inlineCode",{parentName:"li"},"AccountId"),".")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"assetconversionapi"},"assetConversionApi"),(0,o.kt)("h3",{id:"getreservesasset1-framesupporttokensfungibleunionofnativeorwithid-asset2-framesupporttokensfungibleunionofnativeorwithid-optionu128u128"},"getReserves(asset1: ",(0,o.kt)("inlineCode",{parentName:"h3"},"FrameSupportTokensFungibleUnionOfNativeOrWithId"),", asset2: ",(0,o.kt)("inlineCode",{parentName:"h3"},"FrameSupportTokensFungibleUnionOfNativeOrWithId"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<(u128,u128)>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.assetConversionApi.getReserves")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"assetConversionApi_get_reserves")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns the size of the liquidity pool for the given asset pair.")),(0,o.kt)("h3",{id:"quotepriceexacttokensfortokensasset1-framesupporttokensfungibleunionofnativeorwithid-asset2-framesupporttokensfungibleunionofnativeorwithid-amount-u128-include_fee-bool-optionu128"},"quotePriceExactTokensForTokens(asset1: ",(0,o.kt)("inlineCode",{parentName:"h3"},"FrameSupportTokensFungibleUnionOfNativeOrWithId"),", asset2: ",(0,o.kt)("inlineCode",{parentName:"h3"},"FrameSupportTokensFungibleUnionOfNativeOrWithId"),", amount: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u128"),", include_fee: ",(0,o.kt)("inlineCode",{parentName:"h3"},"bool"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<u128>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.assetConversionApi.quotePriceExactTokensForTokens")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"assetConversionApi_quote_price_exact_tokens_for_tokens")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Provides a quote for ","[",(0,o.kt)("inlineCode",{parentName:"li"},"Pallet::swap_exact_tokens_for_tokens"),"]",".,, Note that the price may have changed by the time the transaction is executed., (Use ",(0,o.kt)("inlineCode",{parentName:"li"},"amount_out_min")," to control slippage.)")),(0,o.kt)("h3",{id:"quotepricetokensforexacttokensasset1-framesupporttokensfungibleunionofnativeorwithid-asset2-framesupporttokensfungibleunionofnativeorwithid-amount-u128-include_fee-bool-optionu128"},"quotePriceTokensForExactTokens(asset1: ",(0,o.kt)("inlineCode",{parentName:"h3"},"FrameSupportTokensFungibleUnionOfNativeOrWithId"),", asset2: ",(0,o.kt)("inlineCode",{parentName:"h3"},"FrameSupportTokensFungibleUnionOfNativeOrWithId"),", amount: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u128"),", include_fee: ",(0,o.kt)("inlineCode",{parentName:"h3"},"bool"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<u128>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.assetConversionApi.quotePriceTokensForExactTokens")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"assetConversionApi_quote_price_tokens_for_exact_tokens")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Provides a quote for ","[",(0,o.kt)("inlineCode",{parentName:"li"},"Pallet::swap_tokens_for_exact_tokens"),"]",".,, Note that the price may have changed by the time the transaction is executed., (Use ",(0,o.kt)("inlineCode",{parentName:"li"},"amount_in_max")," to control slippage.)")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"assetsapi"},"assetsApi"),(0,o.kt)("h3",{id:"accountbalancesaccount-spcorecryptoaccountid32-vecu32u128"},"accountBalances(account: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpCoreCryptoAccountId32"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Vec<(u32,u128)>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.assetsApi.accountBalances")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"assetsApi_account_balances")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns the list of ",(0,o.kt)("inlineCode",{parentName:"li"},"AssetId"),"s and corresponding balance that an ",(0,o.kt)("inlineCode",{parentName:"li"},"AccountId")," has.")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"authoritydiscoveryapi"},"authorityDiscoveryApi"),(0,o.kt)("h3",{id:"authorities-vecspauthoritydiscoveryapppublic"},"authorities(): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Vec<SpAuthorityDiscoveryAppPublic>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.authorityDiscoveryApi.authorities")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"authorityDiscoveryApi_authorities")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Retrieve authority identifiers of the current and next authority set.")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"babeapi"},"babeApi"),(0,o.kt)("h3",{id:"configuration-spconsensusbabebabeconfiguration"},"configuration(): ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpConsensusBabeBabeConfiguration")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.babeApi.configuration")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"babeApi_configuration")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Return the configuration for BABE.")),(0,o.kt)("h3",{id:"currentepoch-spconsensusbabeepoch"},"currentEpoch(): ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpConsensusBabeEpoch")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.babeApi.currentEpoch")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"babeApi_current_epoch")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns information regarding the current epoch.")),(0,o.kt)("h3",{id:"currentepochstart-spconsensusslotsslot"},"currentEpochStart(): ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpConsensusSlotsSlot")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.babeApi.currentEpochStart")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"babeApi_current_epoch_start")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns the slot that started the current epoch.")),(0,o.kt)("h3",{id:"generatekeyownershipproofslot-spconsensusslotsslot-authority_id-spconsensusbabeapppublic-optionbytes"},"generateKeyOwnershipProof(slot: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpConsensusSlotsSlot"),", authority_id: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpConsensusBabeAppPublic"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<Bytes>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.babeApi.generateKeyOwnershipProof")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"babeApi_generate_key_ownership_proof")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Generates a proof of key ownership for the given authority in the, current epoch. An example usage of this module is coupled with the, session historical module to prove that a given authority key is, tied to a given staking identity during a specific session. Proofs, of key ownership are necessary for submitting equivocation reports., NOTE: even though the API takes a ",(0,o.kt)("inlineCode",{parentName:"li"},"slot")," as parameter the current, implementations ignores this parameter and instead relies on this, method being called at the correct block height, i.e. any point at, which the epoch for the given slot is live on-chain. Future, implementations will instead use indexed data through an offchain, worker, not requiring older states to be available.")),(0,o.kt)("h3",{id:"nextepoch-spconsensusbabeepoch"},"nextEpoch(): ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpConsensusBabeEpoch")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.babeApi.nextEpoch")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"babeApi_next_epoch")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns information regarding the next epoch (which was already, previously announced).")),(0,o.kt)("h3",{id:"submitreportequivocationunsignedextrinsicequivocation_proof-spconsensusslotsequivocationproof-key_owner_proof-spconsensusbabeopaquekeyownershipproof-optionnull"},"submitReportEquivocationUnsignedExtrinsic(equivocation_proof: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpConsensusSlotsEquivocationProof"),", key_owner_proof: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpConsensusBabeOpaqueKeyOwnershipProof"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<Null>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.babeApi.submitReportEquivocationUnsignedExtrinsic")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"babeApi_submit_report_equivocation_unsigned_extrinsic")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Submits an unsigned extrinsic to report an equivocation. The caller, must provide the equivocation proof and a key ownership proof, (should be obtained using ",(0,o.kt)("inlineCode",{parentName:"li"},"generate_key_ownership_proof"),"). The, extrinsic will be unsigned and should only be accepted for local, authorship (not to be broadcast to the network). This method returns, ",(0,o.kt)("inlineCode",{parentName:"li"},"None")," when creation of the extrinsic fails, e.g. if equivocation, reporting is disabled for the given runtime (i.e. this method is, hardcoded to return ",(0,o.kt)("inlineCode",{parentName:"li"},"None"),"). Only useful in an offchain context.")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"beefyapi"},"beefyApi"),(0,o.kt)("h3",{id:"beefygenesis-optionu32"},"beefyGenesis(): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.beefyApi.beefyGenesis")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"beefyApi_beefy_genesis")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Return the block number where BEEFY consensus is enabled/started")),(0,o.kt)("h3",{id:"generateancestryproofprev_block_number-u32-best_known_block_number-optionu32-optionbytes"},"generateAncestryProof(prev_block_number: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),", best_known_block_number: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<u32>"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<Bytes>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.beefyApi.generateAncestryProof")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"beefyApi_generate_ancestry_proof")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Generates a proof that the ",(0,o.kt)("inlineCode",{parentName:"li"},"prev_block_number")," is part of the canonical chain at, ",(0,o.kt)("inlineCode",{parentName:"li"},"best_known_block_number"),".")),(0,o.kt)("h3",{id:"generatekeyownershipproofset_id-u64-authority_id-spconsensusbeefyecdsacryptopublic-optionbytes"},"generateKeyOwnershipProof(set_id: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u64"),", authority_id: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpConsensusBeefyEcdsaCryptoPublic"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<Bytes>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.beefyApi.generateKeyOwnershipProof")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"beefyApi_generate_key_ownership_proof")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Generates a proof of key ownership for the given authority in the, given set. An example usage of this module is coupled with the, session historical module to prove that a given authority key is, tied to a given staking identity during a specific session. Proofs, of key ownership are necessary for submitting equivocation reports., NOTE: even though the API takes a ",(0,o.kt)("inlineCode",{parentName:"li"},"set_id")," as parameter the current, implementations ignores this parameter and instead relies on this, method being called at the correct block height, i.e. any point at, which the given set id is live on-chain. Future implementations will, instead use indexed data through an offchain worker, not requiring, older states to be available.")),(0,o.kt)("h3",{id:"submitreportdoublevotingunsignedextrinsicequivocation_proof-spconsensusbeefydoublevotingproof-key_owner_proof-spruntimeopaquevalue-optionnull"},"submitReportDoubleVotingUnsignedExtrinsic(equivocation_proof: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpConsensusBeefyDoubleVotingProof"),", key_owner_proof: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpRuntimeOpaqueValue"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<Null>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.beefyApi.submitReportDoubleVotingUnsignedExtrinsic")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"beefyApi_submit_report_double_voting_unsigned_extrinsic")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Submits an unsigned extrinsic to report a double voting equivocation. The caller, must provide the double voting proof and a key ownership proof, (should be obtained using ",(0,o.kt)("inlineCode",{parentName:"li"},"generate_key_ownership_proof"),"). The, extrinsic will be unsigned and should only be accepted for local, authorship (not to be broadcast to the network). This method returns, ",(0,o.kt)("inlineCode",{parentName:"li"},"None")," when creation of the extrinsic fails, e.g. if equivocation, reporting is disabled for the given runtime (i.e. this method is, hardcoded to return ",(0,o.kt)("inlineCode",{parentName:"li"},"None"),"). Only useful in an offchain context.")),(0,o.kt)("h3",{id:"submitreportforkvotingunsignedextrinsicequivocation_proof-spconsensusbeefyforkvotingproofopaquevalue-key_owner_proof-spruntimeopaquevalue-optionnull"},"submitReportForkVotingUnsignedExtrinsic(equivocation_proof: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpConsensusBeefyForkVotingProofOpaqueValue"),", key_owner_proof: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpRuntimeOpaqueValue"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<Null>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.beefyApi.submitReportForkVotingUnsignedExtrinsic")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"beefyApi_submit_report_fork_voting_unsigned_extrinsic")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Submits an unsigned extrinsic to report a fork voting equivocation. The caller, must provide the fork voting proof (the ancestry proof should be obtained using, ",(0,o.kt)("inlineCode",{parentName:"li"},"generate_ancestry_proof"),") and a key ownership proof (should be obtained using, ",(0,o.kt)("inlineCode",{parentName:"li"},"generate_key_ownership_proof"),"). The extrinsic will be unsigned and should only, be accepted for local authorship (not to be broadcast to the network). This method, returns ",(0,o.kt)("inlineCode",{parentName:"li"},"None")," when creation of the extrinsic fails, e.g. if equivocation, reporting is disabled for the given runtime (i.e. this method is, hardcoded to return ",(0,o.kt)("inlineCode",{parentName:"li"},"None"),"). Only useful in an offchain context.")),(0,o.kt)("h3",{id:"submitreportfutureblockvotingunsignedextrinsicequivocation_proof-spconsensusbeefyfutureblockvotingproof-key_owner_proof-spruntimeopaquevalue-optionnull"},"submitReportFutureBlockVotingUnsignedExtrinsic(equivocation_proof: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpConsensusBeefyFutureBlockVotingProof"),", key_owner_proof: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpRuntimeOpaqueValue"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<Null>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.beefyApi.submitReportFutureBlockVotingUnsignedExtrinsic")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"beefyApi_submit_report_future_block_voting_unsigned_extrinsic")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Submits an unsigned extrinsic to report a future block voting equivocation. The caller, must provide the future block voting proof and a key ownership proof, (should be obtained using ",(0,o.kt)("inlineCode",{parentName:"li"},"generate_key_ownership_proof"),")., The extrinsic will be unsigned and should only be accepted for local, authorship (not to be broadcast to the network). This method returns, ",(0,o.kt)("inlineCode",{parentName:"li"},"None")," when creation of the extrinsic fails, e.g. if equivocation, reporting is disabled for the given runtime (i.e. this method is, hardcoded to return ",(0,o.kt)("inlineCode",{parentName:"li"},"None"),"). Only useful in an offchain context.")),(0,o.kt)("h3",{id:"validatorset-optionspconsensusbeefyvalidatorset"},"validatorSet(): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<SpConsensusBeefyValidatorSet>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.beefyApi.validatorSet")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"beefyApi_validator_set")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Return the current active BEEFY validator set")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"blockbuilder"},"blockBuilder"),(0,o.kt)("h3",{id:"applyextrinsicextrinsic-spruntimeuncheckedextrinsic-resultresultnull-spruntimedispatcherror-spruntimetransactionvaliditytransactionvalidityerror"},"applyExtrinsic(extrinsic: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpRuntimeUncheckedExtrinsic"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Result<Result<Null, SpRuntimeDispatchError>, SpRuntimeTransactionValidityTransactionValidityError>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.blockBuilder.applyExtrinsic")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"blockBuilder_apply_extrinsic")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Apply the given extrinsic.,, Returns an inclusion outcome which specifies if this extrinsic is included in, this block or not.")),(0,o.kt)("h3",{id:"checkinherentsblock-spruntimeblock-data-spinherentsinherentdata-spinherentscheckinherentsresult"},"checkInherents(block: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpRuntimeBlock"),", data: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpInherentsInherentData"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpInherentsCheckInherentsResult")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.blockBuilder.checkInherents")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"blockBuilder_check_inherents")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Check that the inherents are valid. The inherent data will vary from chain to chain.")),(0,o.kt)("h3",{id:"finalizeblock-spruntimeheader"},"finalizeBlock(): ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpRuntimeHeader")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.blockBuilder.finalizeBlock")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"blockBuilder_finalize_block")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Finish the current block.")),(0,o.kt)("h3",{id:"inherentextrinsicsinherent-spinherentsinherentdata-vecbytes"},"inherentExtrinsics(inherent: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpInherentsInherentData"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Vec<Bytes>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.blockBuilder.inherentExtrinsics")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"blockBuilder_inherent_extrinsics")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Generate inherent extrinsics. The inherent data will vary from chain to chain.")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"contractsapi"},"contractsApi"),(0,o.kt)("h3",{id:"callorigin-spcorecryptoaccountid32-dest-spcorecryptoaccountid32-value-u128-gas_limit-optionspweightsweightv2weight-storage_deposit_limit-optionu128-input_data-bytes-gasconsumedspweightsweightv2weightgasrequiredspweightsweightv2weightstoragedepositpalletcontractsprimitivesstoragedepositdebugmessagebytesresultresultpalletcontractsprimitivesexecreturnvalue-spruntimedispatcherroreventsoptionvecframesystemeventrecord"},"call(origin: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpCoreCryptoAccountId32"),", dest: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpCoreCryptoAccountId32"),", value: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u128"),", gas_limit: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<SpWeightsWeightV2Weight>"),", storage_deposit_limit: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<u128>"),", input_data: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Bytes"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},'{"gasConsumed":"SpWeightsWeightV2Weight","gasRequired":"SpWeightsWeightV2Weight","storageDeposit":"PalletContractsPrimitivesStorageDeposit","debugMessage":"Bytes","result":"Result<PalletContractsPrimitivesExecReturnValue, SpRuntimeDispatchError>","events":"Option<Vec<FrameSystemEventRecord>>"}')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.contractsApi.call")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"contractsApi_call")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Perform a call from a specified account to a given contract.,, See ","[",(0,o.kt)("inlineCode",{parentName:"li"},"crate::Pallet::bare_call"),"]",".")),(0,o.kt)("h3",{id:"getstorageaddress-spcorecryptoaccountid32-key-bytes-resultoptionbytes-palletcontractsprimitivescontractaccesserror"},"getStorage(address: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpCoreCryptoAccountId32"),", key: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Bytes"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Result<Option<Bytes>, PalletContractsPrimitivesContractAccessError>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.contractsApi.getStorage")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"contractsApi_get_storage")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Query a given storage key in a given contract.,, Returns ",(0,o.kt)("inlineCode",{parentName:"li"},"Ok(Some(Vec<u8>))")," if the storage value exists under the given key in the, specified account and ",(0,o.kt)("inlineCode",{parentName:"li"},"Ok(None)")," if it doesn't. If the account specified by the address, doesn't exist, or doesn't have a contract then ",(0,o.kt)("inlineCode",{parentName:"li"},"Err")," is returned.")),(0,o.kt)("h3",{id:"instantiateorigin-spcorecryptoaccountid32-value-u128-gas_limit-optionspweightsweightv2weight-storage_deposit_limit-optionu128-code-palletcontractsprimitivescode-data-bytes-salt-bytes-palletcontractsprimitivescontractresult"},"instantiate(origin: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpCoreCryptoAccountId32"),", value: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u128"),", gas_limit: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<SpWeightsWeightV2Weight>"),", storage_deposit_limit: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<u128>"),", code: ",(0,o.kt)("inlineCode",{parentName:"h3"},"PalletContractsPrimitivesCode"),", data: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Bytes"),", salt: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Bytes"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"PalletContractsPrimitivesContractResult")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.contractsApi.instantiate")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"contractsApi_instantiate")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Instantiate a new contract.,, See ",(0,o.kt)("inlineCode",{parentName:"li"},"[crate::Pallet::bare_instantiate]"),".")),(0,o.kt)("h3",{id:"uploadcodeorigin-spcorecryptoaccountid32-code-bytes-storage_deposit_limit-optionu128-determinism-palletcontractswasmdeterminism-resultpalletcontractsprimitivescodeuploadreturnvalue-spruntimedispatcherror"},"uploadCode(origin: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpCoreCryptoAccountId32"),", code: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Bytes"),", storage_deposit_limit: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<u128>"),", determinism: ",(0,o.kt)("inlineCode",{parentName:"h3"},"PalletContractsWasmDeterminism"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Result<PalletContractsPrimitivesCodeUploadReturnValue, SpRuntimeDispatchError>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.contractsApi.uploadCode")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"contractsApi_upload_code")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Upload new code without instantiating a contract from it.,, See ","[",(0,o.kt)("inlineCode",{parentName:"li"},"crate::Pallet::bare_upload_code"),"]",".")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"core"},"core"),(0,o.kt)("h3",{id:"executeblockblock-spruntimeblock-null"},"executeBlock(block: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpRuntimeBlock"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Null")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.core.executeBlock")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"core_execute_block")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Execute the given block.")),(0,o.kt)("h3",{id:"initializeblockheader-spruntimeheader-spruntimeextrinsicinclusionmode"},"initializeBlock(header: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpRuntimeHeader"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpRuntimeExtrinsicInclusionMode")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.core.initializeBlock")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"core_initialize_block")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Initialize a block with the given header and return the runtime executive mode.")),(0,o.kt)("h3",{id:"version-spversionruntimeversion"},"version(): ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpVersionRuntimeVersion")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.core.version")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"core_version")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns the version of the runtime.")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"genesisbuilder"},"genesisBuilder"),(0,o.kt)("h3",{id:"buildstatejson-bytes-resultnull-text"},"buildState(json: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Bytes"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Result<Null, Text>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.genesisBuilder.buildState")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"genesisBuilder_build_state")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Build ",(0,o.kt)("inlineCode",{parentName:"li"},"RuntimeGenesisConfig")," from a JSON blob not using any defaults and store it in the, storage.,, In the case of a FRAME-based runtime, this function deserializes the full, ",(0,o.kt)("inlineCode",{parentName:"li"},"RuntimeGenesisConfig")," from the given JSON blob and puts it into the storage. If the, provided JSON blob is incorrect or incomplete or the deserialization fails, an error, is returned.,, Please note that provided JSON blob must contain all ",(0,o.kt)("inlineCode",{parentName:"li"},"RuntimeGenesisConfig")," fields, no, defaults will be used.")),(0,o.kt)("h3",{id:"getpresetid-optiontext-optionbytes"},"getPreset(id: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<Text>"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<Bytes>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.genesisBuilder.getPreset")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"genesisBuilder_get_preset")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns a JSON blob representation of the built-in ",(0,o.kt)("inlineCode",{parentName:"li"},"RuntimeGenesisConfig")," identified by, ",(0,o.kt)("inlineCode",{parentName:"li"},"id"),".,, If ",(0,o.kt)("inlineCode",{parentName:"li"},"id")," is ",(0,o.kt)("inlineCode",{parentName:"li"},"None")," the function should return JSON blob representation of the default, ",(0,o.kt)("inlineCode",{parentName:"li"},"RuntimeGenesisConfig")," struct of the runtime. Implementation must provide default, ",(0,o.kt)("inlineCode",{parentName:"li"},"RuntimeGenesisConfig"),".,, Otherwise function returns a JSON representation of the built-in, named, ",(0,o.kt)("inlineCode",{parentName:"li"},"RuntimeGenesisConfig")," preset identified by ",(0,o.kt)("inlineCode",{parentName:"li"},"id"),", or ",(0,o.kt)("inlineCode",{parentName:"li"},"None")," if such preset does not, exist. Returned ",(0,o.kt)("inlineCode",{parentName:"li"},"Vec<u8>")," contains bytes of JSON blob (patch) which comprises a list of, (potentially nested) key-value pairs that are intended for customizing the default, runtime genesis config. The patch shall be merged (rfc7386) with the JSON representation, of the default ",(0,o.kt)("inlineCode",{parentName:"li"},"RuntimeGenesisConfig")," to create a comprehensive genesis config that can, be used in ",(0,o.kt)("inlineCode",{parentName:"li"},"build_state")," method.")),(0,o.kt)("h3",{id:"presetnames-vectext"},"presetNames(): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Vec<Text>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.genesisBuilder.presetNames")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"genesisBuilder_preset_names")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns a list of identifiers for available builtin ",(0,o.kt)("inlineCode",{parentName:"li"},"RuntimeGenesisConfig")," presets.,, The presets from the list can be queried with ","[",(0,o.kt)("inlineCode",{parentName:"li"},"GenesisBuilder::get_preset"),"]"," method. If, no named presets are provided by the runtime the list is empty.")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"grandpaapi"},"grandpaApi"),(0,o.kt)("h3",{id:"currentsetid-u64"},"currentSetId(): ",(0,o.kt)("inlineCode",{parentName:"h3"},"u64")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.grandpaApi.currentSetId")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"grandpaApi_current_set_id")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Get current GRANDPA authority set id.")),(0,o.kt)("h3",{id:"generatekeyownershipproofset_id-u64-authority_id-spconsensusgrandpaapppublic-optionbytes"},"generateKeyOwnershipProof(set_id: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u64"),", authority_id: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpConsensusGrandpaAppPublic"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<Bytes>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.grandpaApi.generateKeyOwnershipProof")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"grandpaApi_generate_key_ownership_proof")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Generates a proof of key ownership for the given authority in the, given set. An example usage of this module is coupled with the, session historical module to prove that a given authority key is, tied to a given staking identity during a specific session. Proofs, of key ownership are necessary for submitting equivocation reports., NOTE: even though the API takes a ",(0,o.kt)("inlineCode",{parentName:"li"},"set_id")," as parameter the current, implementations ignore this parameter and instead rely on this, method being called at the correct block height, i.e. any point at, which the given set id is live on-chain. Future implementations will, instead use indexed data through an offchain worker, not requiring, older states to be available.")),(0,o.kt)("h3",{id:"grandpaauthorities-vecspconsensusgrandpaapppublicu64"},"grandpaAuthorities(): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Vec<(SpConsensusGrandpaAppPublic,u64)>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.grandpaApi.grandpaAuthorities")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"grandpaApi_grandpa_authorities")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Get the current GRANDPA authorities and weights. This should not change except, for when changes are scheduled and the corresponding delay has passed.,, When called at block B, it will return the set of authorities that should be, used to finalize descendants of this block (B+1, B+2, ...). The block B itself, is finalized by the authorities from block B-1.")),(0,o.kt)("h3",{id:"submitreportequivocationunsignedextrinsicequivocation_proof-spconsensusgrandpaequivocationproof-key_owner_proof-spruntimeopaquevalue-optionnull"},"submitReportEquivocationUnsignedExtrinsic(equivocation_proof: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpConsensusGrandpaEquivocationProof"),", key_owner_proof: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpRuntimeOpaqueValue"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<Null>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.grandpaApi.submitReportEquivocationUnsignedExtrinsic")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"grandpaApi_submit_report_equivocation_unsigned_extrinsic")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Submits an unsigned extrinsic to report an equivocation. The caller, must provide the equivocation proof and a key ownership proof, (should be obtained using ",(0,o.kt)("inlineCode",{parentName:"li"},"generate_key_ownership_proof"),"). The, extrinsic will be unsigned and should only be accepted for local, authorship (not to be broadcast to the network). This method returns, ",(0,o.kt)("inlineCode",{parentName:"li"},"None")," when creation of the extrinsic fails, e.g. if equivocation, reporting is disabled for the given runtime (i.e. this method is, hardcoded to return ",(0,o.kt)("inlineCode",{parentName:"li"},"None"),"). Only useful in an offchain context.")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"metadata"},"metadata"),(0,o.kt)("h3",{id:"metadata-spcoreopaquemetadata"},"metadata(): ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpCoreOpaqueMetadata")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.metadata.metadata")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"metadata_metadata")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns the metadata of a runtime.")),(0,o.kt)("h3",{id:"metadataatversionversion-u32-optionopaquemetadata"},"metadataAtVersion(version: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<OpaqueMetadata>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.metadata.metadataAtVersion")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"metadata_metadata_at_version")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns the metadata at a given version.,, If the given ",(0,o.kt)("inlineCode",{parentName:"li"},"version")," isn't supported, this will return ",(0,o.kt)("inlineCode",{parentName:"li"},"None"),"., Use ","[",(0,o.kt)("inlineCode",{parentName:"li"},"Self::metadata_versions"),"]"," to find out about supported metadata version of the runtime.")),(0,o.kt)("h3",{id:"metadataversions-vecu32"},"metadataVersions(): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Vec<u32>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.metadata.metadataVersions")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"metadata_metadata_versions")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns the supported metadata versions.,, This can be used to call ",(0,o.kt)("inlineCode",{parentName:"li"},"metadata_at_version"),".")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"mixnetapi"},"mixnetApi"),(0,o.kt)("h3",{id:"currentmixnodes-resultvecspmixnetmixnode-spmixnetmixnodeserr"},"currentMixnodes(): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Result<Vec<SpMixnetMixnode>, SpMixnetMixnodesErr>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.mixnetApi.currentMixnodes")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"mixnetApi_current_mixnodes")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Get the mixnode set for the current session.")),(0,o.kt)("h3",{id:"mayberegistersession_index-u32-mixnode-spmixnetmixnode-bool"},"maybeRegister(session_index: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),", mixnode: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpMixnetMixnode"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"bool")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.mixnetApi.maybeRegister")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"mixnetApi_maybe_register")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Try to register a mixnode for the next session.,, If a registration extrinsic is submitted, ",(0,o.kt)("inlineCode",{parentName:"li"},"true")," is returned. The caller should avoid, calling ",(0,o.kt)("inlineCode",{parentName:"li"},"maybe_register")," again for a few blocks, to give the submitted extrinsic a, chance to get included.,, With the above exception, ",(0,o.kt)("inlineCode",{parentName:"li"},"maybe_register")," is designed to be called every block. Most, of the time it will not do anything, for example:,, - If it is not an appropriate time to submit a registration extrinsic., - If the local node has already registered a mixnode for the next session., - If the local node is not permitted to register a mixnode for the next session.,, ",(0,o.kt)("inlineCode",{parentName:"li"},"session_index")," should match ",(0,o.kt)("inlineCode",{parentName:"li"},"session_status().current_index"),"; if it does not, ",(0,o.kt)("inlineCode",{parentName:"li"},"false"),", is returned immediately.")),(0,o.kt)("h3",{id:"prevmixnodes-resultvecspmixnetmixnode-spmixnetmixnodeserr"},"prevMixnodes(): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Result<Vec<SpMixnetMixnode>, SpMixnetMixnodesErr>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.mixnetApi.prevMixnodes")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"mixnetApi_prev_mixnodes")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Get the mixnode set for the previous session.")),(0,o.kt)("h3",{id:"sessionstatus-spmixnetsessionstatus"},"sessionStatus(): ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpMixnetSessionStatus")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.mixnetApi.sessionStatus")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"mixnetApi_session_status")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Get the index and phase of the current session.")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"mmrapi"},"mmrApi"),(0,o.kt)("h3",{id:"generateproofblock_numbers-vecu32-best_known_block_number-optionu32-resultvecbytesspmmrprimitivesleafproof-spmmrprimitiveserror"},"generateProof(block_numbers: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Vec<u32>"),", best_known_block_number: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<u32>"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Result<(Vec<Bytes>,SpMmrPrimitivesLeafProof), SpMmrPrimitivesError>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.mmrApi.generateProof")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"mmrApi_generate_proof")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Generate MMR proof for a series of block numbers. If ",(0,o.kt)("inlineCode",{parentName:"li"},"best_known_block_number = Some(n)"),",, use historical MMR state at given block height ",(0,o.kt)("inlineCode",{parentName:"li"},"n"),". Else, use current MMR state.")),(0,o.kt)("h3",{id:"mmrleafcount-resultu64-spmmrprimitiveserror"},"mmrLeafCount(): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Result<u64, SpMmrPrimitivesError>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.mmrApi.mmrLeafCount")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"mmrApi_mmr_leaf_count")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Return the number of MMR blocks in the chain.")),(0,o.kt)("h3",{id:"mmrroot-resulth256-spmmrprimitiveserror"},"mmrRoot(): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Result<H256, SpMmrPrimitivesError>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.mmrApi.mmrRoot")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"mmrApi_mmr_root")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Return the on-chain MMR root hash.")),(0,o.kt)("h3",{id:"verifyproofleaves-vecbytes-proof-spmmrprimitivesleafproof-resultnull-spmmrprimitiveserror"},"verifyProof(leaves: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Vec<Bytes>"),", proof: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpMmrPrimitivesLeafProof"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Result<Null, SpMmrPrimitivesError>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.mmrApi.verifyProof")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"mmrApi_verify_proof")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Verify MMR proof against on-chain MMR for a batch of leaves.,, Note this function will use on-chain MMR root hash and check if the proof matches the hash., Note, the leaves should be sorted such that corresponding leaves and leaf indices have the, same position in both the ",(0,o.kt)("inlineCode",{parentName:"li"},"leaves")," vector and the ",(0,o.kt)("inlineCode",{parentName:"li"},"leaf_indices")," vector contained in the ","[LeafProof]")),(0,o.kt)("h3",{id:"verifyproofstatelessroot-primitivetypesh256-leaves-vecbytes-proof-spmmrprimitivesleafproof-resultnull-spmmrprimitiveserror"},"verifyProofStateless(root: ",(0,o.kt)("inlineCode",{parentName:"h3"},"PrimitiveTypesH256"),", leaves: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Vec<Bytes>"),", proof: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpMmrPrimitivesLeafProof"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Result<Null, SpMmrPrimitivesError>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.mmrApi.verifyProofStateless")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"mmrApi_verify_proof_stateless")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Verify MMR proof against given root hash for a batch of leaves.,, Note this function does not require any on-chain storage - the, proof is verified against given MMR root hash.,, Note, the leaves should be sorted such that corresponding leaves and leaf indices have the, same position in both the ",(0,o.kt)("inlineCode",{parentName:"li"},"leaves")," vector and the ",(0,o.kt)("inlineCode",{parentName:"li"},"leaf_indices")," vector contained in the ","[LeafProof]")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"nftsapi"},"nftsApi"),(0,o.kt)("h3",{id:"attributecollection-u32-item-u32-key-bytes-optionbytes"},"attribute(collection: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),", item: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),", key: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Bytes"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<Bytes>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.nftsApi.attribute")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"nftsApi_attribute")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),": ")),(0,o.kt)("h3",{id:"collectionattributecollection-u32-key-bytes-optionbytes"},"collectionAttribute(collection: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),", key: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Bytes"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<Bytes>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.nftsApi.collectionAttribute")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"nftsApi_collection_attribute")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),": ")),(0,o.kt)("h3",{id:"collectionownercollection-u32-optionaccountid32"},"collectionOwner(collection: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<AccountId32>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.nftsApi.collectionOwner")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"nftsApi_collection_owner")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),": ")),(0,o.kt)("h3",{id:"customattributeaccount-spcorecryptoaccountid32-collection-u32-item-u32-key-bytes-optionbytes"},"customAttribute(account: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpCoreCryptoAccountId32"),", collection: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),", item: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),", key: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Bytes"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<Bytes>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.nftsApi.customAttribute")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"nftsApi_custom_attribute")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),": ")),(0,o.kt)("h3",{id:"ownercollection-u32-item-u32-optionaccountid32"},"owner(collection: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),", item: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<AccountId32>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.nftsApi.owner")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"nftsApi_owner")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),": ")),(0,o.kt)("h3",{id:"systemattributecollection-u32-item-optionu32-key-bytes-optionbytes"},"systemAttribute(collection: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),", item: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<u32>"),", key: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Bytes"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<Bytes>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.nftsApi.systemAttribute")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"nftsApi_system_attribute")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),": ")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"nominationpoolsapi"},"nominationPoolsApi"),(0,o.kt)("h3",{id:"balancetopointspool_id-u32-new_funds-u128-u128"},"balanceToPoints(pool_id: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),", new_funds: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u128"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"u128")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.nominationPoolsApi.balanceToPoints")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"nominationPoolsApi_balance_to_points")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns the equivalent points of ",(0,o.kt)("inlineCode",{parentName:"li"},"new_funds")," for a given pool.")),(0,o.kt)("h3",{id:"memberneedsdelegatemigrationmember-spcorecryptoaccountid32-bool"},"memberNeedsDelegateMigration(member: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpCoreCryptoAccountId32"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"bool")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.nominationPoolsApi.memberNeedsDelegateMigration")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"nominationPoolsApi_member_needs_delegate_migration")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns true if the delegated funds of the pool ",(0,o.kt)("inlineCode",{parentName:"li"},"member")," needs migration.,, Once a pool has successfully migrated to the strategy, ",(0,o.kt)("a",{parentName:"li",href:"pallet_nomination_pools::adapter::DelegateStake"},(0,o.kt)("inlineCode",{parentName:"a"},"DelegateStake")),", the funds of the, member can be migrated from pool account to the member's account. Use, ",(0,o.kt)("a",{parentName:"li",href:"pallet_nomination_pools::Call::migrate_delegation"},(0,o.kt)("inlineCode",{parentName:"a"},"migrate_delegation")),", to migrate the funds of the pool member.")),(0,o.kt)("h3",{id:"memberpendingslashmember-spcorecryptoaccountid32-u128"},"memberPendingSlash(member: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpCoreCryptoAccountId32"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"u128")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.nominationPoolsApi.memberPendingSlash")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"nominationPoolsApi_member_pending_slash")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns the pending slash for a given pool member.")),(0,o.kt)("h3",{id:"membertotalbalancewho-spcorecryptoaccountid32-u128"},"memberTotalBalance(who: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpCoreCryptoAccountId32"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"u128")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.nominationPoolsApi.memberTotalBalance")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"nominationPoolsApi_member_total_balance")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns the total contribution of a pool member including any balance that is unbonding.")),(0,o.kt)("h3",{id:"pendingrewardswho-spcorecryptoaccountid32-u128"},"pendingRewards(who: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpCoreCryptoAccountId32"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"u128")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.nominationPoolsApi.pendingRewards")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"nominationPoolsApi_pending_rewards")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns the pending rewards for the member that the AccountId was given for.")),(0,o.kt)("h3",{id:"pointstobalancepool_id-u32-points-u128-u128"},"pointsToBalance(pool_id: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),", points: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u128"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"u128")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.nominationPoolsApi.pointsToBalance")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"nominationPoolsApi_points_to_balance")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns the equivalent balance of ",(0,o.kt)("inlineCode",{parentName:"li"},"points")," for a given pool.")),(0,o.kt)("h3",{id:"poolaccountspool_id-u32-accountid32accountid32"},"poolAccounts(pool_id: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"(AccountId32,AccountId32)")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.nominationPoolsApi.poolAccounts")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"nominationPoolsApi_pool_accounts")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns the bonded account and reward account associated with the pool_id.")),(0,o.kt)("h3",{id:"poolbalancepool_id-u32-u128"},"poolBalance(pool_id: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"u128")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.nominationPoolsApi.poolBalance")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"nominationPoolsApi_pool_balance")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Total balance contributed to the pool.")),(0,o.kt)("h3",{id:"poolneedsdelegatemigrationpool_id-u32-bool"},"poolNeedsDelegateMigration(pool_id: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"bool")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.nominationPoolsApi.poolNeedsDelegateMigration")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"nominationPoolsApi_pool_needs_delegate_migration")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns true if the pool with ",(0,o.kt)("inlineCode",{parentName:"li"},"pool_id")," needs migration.,, This can happen when the ",(0,o.kt)("inlineCode",{parentName:"li"},"pallet-nomination-pools")," has switched to using strategy, ",(0,o.kt)("a",{parentName:"li",href:"pallet_nomination_pools::adapter::DelegateStake"},(0,o.kt)("inlineCode",{parentName:"a"},"DelegateStake"))," but the pool, still has funds that were staked using the older strategy, ",(0,o.kt)("a",{parentName:"li",href:"pallet_nomination_pools::adapter::TransferStake"},"TransferStake"),". Use, ",(0,o.kt)("a",{parentName:"li",href:"pallet_nomination_pools::Call::migrate_pool_to_delegate_stake"},(0,o.kt)("inlineCode",{parentName:"a"},"migrate_pool_to_delegate_stake")),", to migrate the pool.")),(0,o.kt)("h3",{id:"poolpendingslashpool_id-u32-u128"},"poolPendingSlash(pool_id: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"u128")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.nominationPoolsApi.poolPendingSlash")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"nominationPoolsApi_pool_pending_slash")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns the pending slash for a given pool.")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"offchainworkerapi"},"offchainWorkerApi"),(0,o.kt)("h3",{id:"offchainworkerheader-spruntimeheader-null"},"offchainWorker(header: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpRuntimeHeader"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Null")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.offchainWorkerApi.offchainWorker")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"offchainWorkerApi_offchain_worker")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Starts the off-chain task for given block header.")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"reviveapi"},"reviveApi"),(0,o.kt)("h3",{id:"balanceaddress-primitivetypesh160-u128"},"balance(address: ",(0,o.kt)("inlineCode",{parentName:"h3"},"PrimitiveTypesH160"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"u128")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.reviveApi.balance")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"reviveApi_balance")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns the free balance of the given ",(0,o.kt)("inlineCode",{parentName:"li"},"[H160]")," address.")),(0,o.kt)("h3",{id:"callorigin-spcorecryptoaccountid32-dest-primitivetypesh160-value-u128-gas_limit-optionspweightsweightv2weight-storage_deposit_limit-optionu128-input_data-bytes-palletreviveprimitivescontractresultexecreturnvalue"},"call(origin: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpCoreCryptoAccountId32"),", dest: ",(0,o.kt)("inlineCode",{parentName:"h3"},"PrimitiveTypesH160"),", value: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u128"),", gas_limit: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<SpWeightsWeightV2Weight>"),", storage_deposit_limit: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<u128>"),", input_data: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Bytes"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"PalletRevivePrimitivesContractResultExecReturnValue")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.reviveApi.call")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"reviveApi_call")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Perform a call from a specified account to a given contract.,, See ","[",(0,o.kt)("inlineCode",{parentName:"li"},"crate::Pallet::bare_call"),"]",".")),(0,o.kt)("h3",{id:"ethtransactorigin-primitivetypesh160-dest-optionh160-value-u128-input-bytes-gas_limit-optionspweightsweightv2weight-storage_deposit_limit-optionu128-palletreviveprimitivesethcontractresult"},"ethTransact(origin: ",(0,o.kt)("inlineCode",{parentName:"h3"},"PrimitiveTypesH160"),", dest: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<H160>"),", value: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u128"),", input: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Bytes"),", gas_limit: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<SpWeightsWeightV2Weight>"),", storage_deposit_limit: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<u128>"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"PalletRevivePrimitivesEthContractResult")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.reviveApi.ethTransact")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"reviveApi_eth_transact")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Perform an Ethereum call.,, See ","[",(0,o.kt)("inlineCode",{parentName:"li"},"crate::Pallet::bare_eth_transact"),"]")),(0,o.kt)("h3",{id:"getstorageaddress-primitivetypesh160-key-u832-resultoptionbytes-palletreviveprimitivescontractaccesserror"},"getStorage(address: ",(0,o.kt)("inlineCode",{parentName:"h3"},"PrimitiveTypesH160"),", key: ",(0,o.kt)("inlineCode",{parentName:"h3"},"[u8;32]"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Result<Option<Bytes>, PalletRevivePrimitivesContractAccessError>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.reviveApi.getStorage")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"reviveApi_get_storage")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Query a given storage key in a given contract.,, Returns ",(0,o.kt)("inlineCode",{parentName:"li"},"Ok(Some(Vec<u8>))")," if the storage value exists under the given key in the, specified account and ",(0,o.kt)("inlineCode",{parentName:"li"},"Ok(None)")," if it doesn't. If the account specified by the address, doesn't exist, or doesn't have a contract then ",(0,o.kt)("inlineCode",{parentName:"li"},"Err")," is returned.")),(0,o.kt)("h3",{id:"instantiateorigin-spcorecryptoaccountid32-value-u128-gas_limit-optionspweightsweightv2weight-storage_deposit_limit-optionu128-code-palletreviveprimitivescode-data-bytes-salt-optionu832-palletreviveprimitivescontractresultinstantiatereturnvalue"},"instantiate(origin: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpCoreCryptoAccountId32"),", value: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u128"),", gas_limit: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<SpWeightsWeightV2Weight>"),", storage_deposit_limit: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<u128>"),", code: ",(0,o.kt)("inlineCode",{parentName:"h3"},"PalletRevivePrimitivesCode"),", data: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Bytes"),", salt: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<[u8;32]>"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"PalletRevivePrimitivesContractResultInstantiateReturnValue")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.reviveApi.instantiate")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"reviveApi_instantiate")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Instantiate a new contract.,, See ",(0,o.kt)("inlineCode",{parentName:"li"},"[crate::Pallet::bare_instantiate]"),".")),(0,o.kt)("h3",{id:"nonceaddress-primitivetypesh160-u32"},"nonce(address: ",(0,o.kt)("inlineCode",{parentName:"h3"},"PrimitiveTypesH160"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.reviveApi.nonce")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"reviveApi_nonce")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns the nonce of the given ",(0,o.kt)("inlineCode",{parentName:"li"},"[H160]")," address.")),(0,o.kt)("h3",{id:"uploadcodeorigin-spcorecryptoaccountid32-code-bytes-storage_deposit_limit-optionu128-resultpalletreviveprimitivescodeuploadreturnvalue-spruntimedispatcherror"},"uploadCode(origin: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpCoreCryptoAccountId32"),", code: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Bytes"),", storage_deposit_limit: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<u128>"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Result<PalletRevivePrimitivesCodeUploadReturnValue, SpRuntimeDispatchError>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.reviveApi.uploadCode")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"reviveApi_upload_code")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Upload new code without instantiating a contract from it.,, See ","[",(0,o.kt)("inlineCode",{parentName:"li"},"crate::Pallet::bare_upload_code"),"]",".")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"sessionkeys"},"sessionKeys"),(0,o.kt)("h3",{id:"decodesessionkeysencoded-bytes-optionvecbytesspcorecryptokeytypeid"},"decodeSessionKeys(encoded: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Bytes"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<Vec<(Bytes,SpCoreCryptoKeyTypeId)>>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.sessionKeys.decodeSessionKeys")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"sessionKeys_decode_session_keys")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Decode the given public session keys.,, Returns the list of public raw public keys + key type.")),(0,o.kt)("h3",{id:"generatesessionkeysseed-optionbytes-bytes"},"generateSessionKeys(seed: ",(0,o.kt)("inlineCode",{parentName:"h3"},"Option<Bytes>"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Bytes")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.sessionKeys.generateSessionKeys")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"sessionKeys_generate_session_keys")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Generate a set of session keys with optionally using the given seed., The keys should be stored within the keystore exposed via runtime, externalities.,, The seed needs to be a valid ",(0,o.kt)("inlineCode",{parentName:"li"},"utf8")," string.,, Returns the concatenated SCALE encoded public keys.")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"stakingapi"},"stakingApi"),(0,o.kt)("h3",{id:"erasstakerspagecountera-u32-account-spcorecryptoaccountid32-u32"},"erasStakersPageCount(era: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),", account: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpCoreCryptoAccountId32"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.stakingApi.erasStakersPageCount")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"stakingApi_eras_stakers_page_count")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns the page count of exposures for a validator ",(0,o.kt)("inlineCode",{parentName:"li"},"account")," in a given era.")),(0,o.kt)("h3",{id:"nominationsquotabalance-u128-u32"},"nominationsQuota(balance: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u128"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.stakingApi.nominationsQuota")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"stakingApi_nominations_quota")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns the nominations quota for a nominator with a given balance.")),(0,o.kt)("h3",{id:"pendingrewardsera-u32-account-spcorecryptoaccountid32-bool"},"pendingRewards(era: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),", account: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpCoreCryptoAccountId32"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"bool")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.stakingApi.pendingRewards")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"stakingApi_pending_rewards")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Returns true if validator ",(0,o.kt)("inlineCode",{parentName:"li"},"account")," has pages to be claimed for the given era.")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"taggedtransactionqueue"},"taggedTransactionQueue"),(0,o.kt)("h3",{id:"validatetransactionsource-spruntimetransactionvaliditytransactionsource-tx-spruntimeuncheckedextrinsic-block_hash-primitivetypesh256-resultspruntimetransactionvalidityvalidtransaction-spruntimetransactionvaliditytransactionvalidityerror"},"validateTransaction(source: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpRuntimeTransactionValidityTransactionSource"),", tx: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpRuntimeUncheckedExtrinsic"),", block_hash: ",(0,o.kt)("inlineCode",{parentName:"h3"},"PrimitiveTypesH256"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Result<SpRuntimeTransactionValidityValidTransaction, SpRuntimeTransactionValidityTransactionValidityError>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.taggedTransactionQueue.validateTransaction")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"taggedTransactionQueue_validate_transaction")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Validate the transaction.,, This method is invoked by the transaction pool to learn details about given transaction., The implementation should make sure to verify the correctness of the transaction, against current state. The given ",(0,o.kt)("inlineCode",{parentName:"li"},"block_hash")," corresponds to the hash of the block, that is used as current state.,, Note that this call may be performed by the pool multiple times and transactions, might be verified in any possible order.")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"transactionpaymentapi"},"transactionPaymentApi"),(0,o.kt)("h3",{id:"queryfeedetailsuxt-spruntimeuncheckedextrinsic-len-u32-pallettransactionpaymentfeedetails"},"queryFeeDetails(uxt: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpRuntimeUncheckedExtrinsic"),", len: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"PalletTransactionPaymentFeeDetails")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.transactionPaymentApi.queryFeeDetails")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"transactionPaymentApi_query_fee_details")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),": ")),(0,o.kt)("h3",{id:"queryinfouxt-spruntimeuncheckedextrinsic-len-u32-pallettransactionpaymentruntimedispatchinfo"},"queryInfo(uxt: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpRuntimeUncheckedExtrinsic"),", len: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"PalletTransactionPaymentRuntimeDispatchInfo")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.transactionPaymentApi.queryInfo")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"transactionPaymentApi_query_info")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),": ")),(0,o.kt)("h3",{id:"querylengthtofeelength-u32-u128"},"queryLengthToFee(length: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"u128")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.transactionPaymentApi.queryLengthToFee")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"transactionPaymentApi_query_length_to_fee")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),": ")),(0,o.kt)("h3",{id:"queryweighttofeeweight-spweightsweightv2weight-u128"},"queryWeightToFee(weight: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpWeightsWeightV2Weight"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"u128")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.transactionPaymentApi.queryWeightToFee")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"transactionPaymentApi_query_weight_to_fee")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),": ")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"transactionpaymentcallapi"},"transactionPaymentCallApi"),(0,o.kt)("h3",{id:"querycallfeedetailscall-kitchensinkruntimeruntimecall-len-u32-pallettransactionpaymentfeedetails"},"queryCallFeeDetails(call: ",(0,o.kt)("inlineCode",{parentName:"h3"},"KitchensinkRuntimeRuntimeCall"),", len: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"PalletTransactionPaymentFeeDetails")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.transactionPaymentCallApi.queryCallFeeDetails")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"transactionPaymentCallApi_query_call_fee_details")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Query fee details of a given encoded ",(0,o.kt)("inlineCode",{parentName:"li"},"Call"),".")),(0,o.kt)("h3",{id:"querycallinfocall-kitchensinkruntimeruntimecall-len-u32-pallettransactionpaymentruntimedispatchinfo"},"queryCallInfo(call: ",(0,o.kt)("inlineCode",{parentName:"h3"},"KitchensinkRuntimeRuntimeCall"),", len: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"PalletTransactionPaymentRuntimeDispatchInfo")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.transactionPaymentCallApi.queryCallInfo")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"transactionPaymentCallApi_query_call_info")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Query information of a dispatch class, weight, and fee of a given encoded ",(0,o.kt)("inlineCode",{parentName:"li"},"Call"),".")),(0,o.kt)("h3",{id:"querylengthtofeelength-u32-u128-1"},"queryLengthToFee(length: ",(0,o.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"u128")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.transactionPaymentCallApi.queryLengthToFee")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"transactionPaymentCallApi_query_length_to_fee")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Query the output of the current ",(0,o.kt)("inlineCode",{parentName:"li"},"LengthToFee")," given some input.")),(0,o.kt)("h3",{id:"queryweighttofeeweight-spweightsweightv2weight-u128-1"},"queryWeightToFee(weight: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpWeightsWeightV2Weight"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"u128")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.transactionPaymentCallApi.queryWeightToFee")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"transactionPaymentCallApi_query_weight_to_fee")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Query the output of the current ",(0,o.kt)("inlineCode",{parentName:"li"},"WeightToFee")," given some input.")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"validatestatement"},"validateStatement"),(0,o.kt)("h3",{id:"validatestatementsource-spstatementstoreruntimeapistatementsource-statement-spstatementstorestatement-resultspstatementstoreruntimeapivalidstatement-spstatementstoreruntimeapiinvalidstatement"},"validateStatement(source: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpStatementStoreRuntimeApiStatementSource"),", statement: ",(0,o.kt)("inlineCode",{parentName:"h3"},"SpStatementStoreStatement"),"): ",(0,o.kt)("inlineCode",{parentName:"h3"},"Result<SpStatementStoreRuntimeApiValidStatement, SpStatementStoreRuntimeApiInvalidStatement>")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"interface"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"api.call.validateStatement.validateStatement")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"runtime"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"validateStatement_validate_statement")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"summary"),":  Validate the statement.")))}k.isMDXComponent=!0}}]);