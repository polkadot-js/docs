"use strict";(self.webpackChunkpolkadot_js=self.webpackChunkpolkadot_js||[]).push([[2194],{4137:function(e,t,a){a.d(t,{Zo:function(){return u},kt:function(){return k}});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=p(a),c=i,k=d["".concat(s,".").concat(c)]||d[c]||m[c]||r;return a?n.createElement(k,o(o({ref:t},u),{},{components:a})):n.createElement(k,o({ref:t},u))}));function k(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},8307:function(e,t,a){a.r(t),a.d(t,{assets:function(){return u},contentTitle:function(){return s},default:function(){return k},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return d}});var n=a(7462),i=a(3366),r=(a(7294),a(4137)),o=["components"],l={title:"Storage"},s=void 0,p={unversionedId:"kusama/storage",id:"kusama/storage",title:"Storage",description:"The following sections contain Storage methods are part of the default Kusama runtime. On the api, these are exposed via api.query...",source:"@site/docs/kusama/storage.md",sourceDirName:"kusama",slug:"/kusama/storage",permalink:"/docs/kusama/storage",draft:!1,editUrl:"https://github.com/polkadot-js/docs/edit/master/docs/kusama/storage.md",tags:[],version:"current",frontMatter:{title:"Storage"},sidebar:"reference",previous:{title:"Constants",permalink:"/docs/kusama/constants"},next:{title:"Extrinsics",permalink:"/docs/kusama/extrinsics"}},u={},d=[{value:"assetRate",id:"assetrate",level:2},{value:"conversionRateToNative(<code>PolkadotRuntimeCommonImplsVersionedLocatableAsset</code>): <code>Option&lt;u128&gt;</code>",id:"conversionratetonativepolkadotruntimecommonimplsversionedlocatableasset-optionu128",level:3},{value:"auctions",id:"auctions",level:2},{value:"auctionCounter(): <code>u32</code>",id:"auctioncounter-u32",level:3},{value:"auctionInfo(): <code>Option&lt;(u32,u32)&gt;</code>",id:"auctioninfo-optionu32u32",level:3},{value:"reservedAmounts(<code>(AccountId32,u32)</code>): <code>Option&lt;u128&gt;</code>",id:"reservedamountsaccountid32u32-optionu128",level:3},{value:"winning(<code>u32</code>): <code>Option&lt;[Option&lt;(AccountId32,u32,u128)&gt;;36]&gt;</code>",id:"winningu32-optionoptionaccountid32u32u12836",level:3},{value:"authorityDiscovery",id:"authoritydiscovery",level:2},{value:"keys(): <code>Vec&lt;SpAuthorityDiscoveryAppPublic&gt;</code>",id:"keys-vecspauthoritydiscoveryapppublic",level:3},{value:"nextKeys(): <code>Vec&lt;SpAuthorityDiscoveryAppPublic&gt;</code>",id:"nextkeys-vecspauthoritydiscoveryapppublic",level:3},{value:"authorship",id:"authorship",level:2},{value:"author(): <code>Option&lt;AccountId32&gt;</code>",id:"author-optionaccountid32",level:3},{value:"babe",id:"babe",level:2},{value:"authorities(): <code>Vec&lt;(SpConsensusBabeAppPublic,u64)&gt;</code>",id:"authorities-vecspconsensusbabeapppublicu64",level:3},{value:"authorVrfRandomness(): <code>Option&lt;[u8;32]&gt;</code>",id:"authorvrfrandomness-optionu832",level:3},{value:"currentSlot(): <code>u64</code>",id:"currentslot-u64",level:3},{value:"epochConfig(): <code>Option&lt;SpConsensusBabeBabeEpochConfiguration&gt;</code>",id:"epochconfig-optionspconsensusbabebabeepochconfiguration",level:3},{value:"epochIndex(): <code>u64</code>",id:"epochindex-u64",level:3},{value:"epochStart(): <code>(u32,u32)</code>",id:"epochstart-u32u32",level:3},{value:"genesisSlot(): <code>u64</code>",id:"genesisslot-u64",level:3},{value:"initialized(): <code>Option&lt;Option&lt;SpConsensusBabeDigestsPreDigest&gt;&gt;</code>",id:"initialized-optionoptionspconsensusbabedigestspredigest",level:3},{value:"lateness(): <code>u32</code>",id:"lateness-u32",level:3},{value:"nextAuthorities(): <code>Vec&lt;(SpConsensusBabeAppPublic,u64)&gt;</code>",id:"nextauthorities-vecspconsensusbabeapppublicu64",level:3},{value:"nextEpochConfig(): <code>Option&lt;SpConsensusBabeBabeEpochConfiguration&gt;</code>",id:"nextepochconfig-optionspconsensusbabebabeepochconfiguration",level:3},{value:"nextRandomness(): <code>[u8;32]</code>",id:"nextrandomness-u832",level:3},{value:"pendingEpochConfigChange(): <code>Option&lt;SpConsensusBabeDigestsNextConfigDescriptor&gt;</code>",id:"pendingepochconfigchange-optionspconsensusbabedigestsnextconfigdescriptor",level:3},{value:"randomness(): <code>[u8;32]</code>",id:"randomness-u832",level:3},{value:"segmentIndex(): <code>u32</code>",id:"segmentindex-u32",level:3},{value:"skippedEpochs(): <code>Vec&lt;(u64,u32)&gt;</code>",id:"skippedepochs-vecu64u32",level:3},{value:"underConstruction(<code>u32</code>): <code>Vec&lt;[u8;32]&gt;</code>",id:"underconstructionu32-vecu832",level:3},{value:"balances",id:"balances",level:2},{value:"account(<code>AccountId32</code>): <code>PalletBalancesAccountData</code>",id:"accountaccountid32-palletbalancesaccountdata",level:3},{value:"freezes(<code>AccountId32</code>): <code>Vec&lt;{&quot;id&quot;:&quot;StagingKusamaRuntimeRuntimeFreezeReason&quot;,&quot;amount&quot;:&quot;u128&quot;}&gt;</code>",id:"freezesaccountid32-vecidstagingkusamaruntimeruntimefreezereasonamountu128",level:3},{value:"holds(<code>AccountId32</code>): <code>Vec&lt;{&quot;id&quot;:&quot;StagingKusamaRuntimeRuntimeHoldReason&quot;,&quot;amount&quot;:&quot;u128&quot;}&gt;</code>",id:"holdsaccountid32-vecidstagingkusamaruntimeruntimeholdreasonamountu128",level:3},{value:"inactiveIssuance(): <code>u128</code>",id:"inactiveissuance-u128",level:3},{value:"locks(<code>AccountId32</code>): <code>Vec&lt;PalletBalancesBalanceLock&gt;</code>",id:"locksaccountid32-vecpalletbalancesbalancelock",level:3},{value:"reserves(<code>AccountId32</code>): <code>Vec&lt;PalletBalancesReserveData&gt;</code>",id:"reservesaccountid32-vecpalletbalancesreservedata",level:3},{value:"totalIssuance(): <code>u128</code>",id:"totalissuance-u128",level:3},{value:"beefy",id:"beefy",level:2},{value:"authorities(): <code>Vec&lt;SpConsensusBeefyEcdsaCryptoPublic&gt;</code>",id:"authorities-vecspconsensusbeefyecdsacryptopublic",level:3},{value:"genesisBlock(): <code>Option&lt;u32&gt;</code>",id:"genesisblock-optionu32",level:3},{value:"nextAuthorities(): <code>Vec&lt;SpConsensusBeefyEcdsaCryptoPublic&gt;</code>",id:"nextauthorities-vecspconsensusbeefyecdsacryptopublic",level:3},{value:"setIdSession(<code>u64</code>): <code>Option&lt;u32&gt;</code>",id:"setidsessionu64-optionu32",level:3},{value:"validatorSetId(): <code>u64</code>",id:"validatorsetid-u64",level:3},{value:"beefyMmrLeaf",id:"beefymmrleaf",level:2},{value:"beefyAuthorities(): <code>SpConsensusBeefyMmrBeefyAuthoritySet</code>",id:"beefyauthorities-spconsensusbeefymmrbeefyauthorityset",level:3},{value:"beefyNextAuthorities(): <code>SpConsensusBeefyMmrBeefyAuthoritySet</code>",id:"beefynextauthorities-spconsensusbeefymmrbeefyauthorityset",level:3},{value:"bounties",id:"bounties",level:2},{value:"bounties(<code>u32</code>): <code>Option&lt;PalletBountiesBounty&gt;</code>",id:"bountiesu32-optionpalletbountiesbounty",level:3},{value:"bountyApprovals(): <code>Vec&lt;u32&gt;</code>",id:"bountyapprovals-vecu32",level:3},{value:"bountyCount(): <code>u32</code>",id:"bountycount-u32",level:3},{value:"bountyDescriptions(<code>u32</code>): <code>Option&lt;Bytes&gt;</code>",id:"bountydescriptionsu32-optionbytes",level:3},{value:"childBounties",id:"childbounties",level:2},{value:"childBounties(<code>u32, u32</code>): <code>Option&lt;PalletChildBountiesChildBounty&gt;</code>",id:"childbountiesu32-u32-optionpalletchildbountieschildbounty",level:3},{value:"childBountyCount(): <code>u32</code>",id:"childbountycount-u32",level:3},{value:"childBountyDescriptionsV1(<code>u32, u32</code>): <code>Option&lt;Bytes&gt;</code>",id:"childbountydescriptionsv1u32-u32-optionbytes",level:3},{value:"childrenCuratorFees(<code>u32</code>): <code>u128</code>",id:"childrencuratorfeesu32-u128",level:3},{value:"parentChildBounties(<code>u32</code>): <code>u32</code>",id:"parentchildbountiesu32-u32",level:3},{value:"parentTotalChildBounties(<code>u32</code>): <code>u32</code>",id:"parenttotalchildbountiesu32-u32",level:3},{value:"v0ToV1ChildBountyIds(<code>u32</code>): <code>Option&lt;(u32,u32)&gt;</code>",id:"v0tov1childbountyidsu32-optionu32u32",level:3},{value:"claims",id:"claims",level:2},{value:"claims(<code>EthereumAddress</code>): <code>Option&lt;u128&gt;</code>",id:"claimsethereumaddress-optionu128",level:3},{value:"preclaims(<code>AccountId32</code>): <code>Option&lt;EthereumAddress&gt;</code>",id:"preclaimsaccountid32-optionethereumaddress",level:3},{value:"signing(<code>EthereumAddress</code>): <code>Option&lt;PolkadotRuntimeCommonClaimsStatementKind&gt;</code>",id:"signingethereumaddress-optionpolkadotruntimecommonclaimsstatementkind",level:3},{value:"total(): <code>u128</code>",id:"total-u128",level:3},{value:"vesting(<code>EthereumAddress</code>): <code>Option&lt;(u128,u128,u32)&gt;</code>",id:"vestingethereumaddress-optionu128u128u32",level:3},{value:"configuration",id:"configuration",level:2},{value:"activeConfig(): <code>PolkadotRuntimeParachainsConfigurationHostConfiguration</code>",id:"activeconfig-polkadotruntimeparachainsconfigurationhostconfiguration",level:3},{value:"bypassConsistencyCheck(): <code>bool</code>",id:"bypassconsistencycheck-bool",level:3},{value:"pendingConfigs(): <code>Vec&lt;(u32,PolkadotRuntimeParachainsConfigurationHostConfiguration)&gt;</code>",id:"pendingconfigs-vecu32polkadotruntimeparachainsconfigurationhostconfiguration",level:3},{value:"convictionVoting",id:"convictionvoting",level:2},{value:"classLocksFor(<code>AccountId32</code>): <code>Vec&lt;(u16,u128)&gt;</code>",id:"classlocksforaccountid32-vecu16u128",level:3},{value:"votingFor(<code>AccountId32, u16</code>): <code>PalletConvictionVotingVoteVoting</code>",id:"votingforaccountid32-u16-palletconvictionvotingvotevoting",level:3},{value:"coretimeAssignmentProvider",id:"coretimeassignmentprovider",level:2},{value:"coreDescriptors(<code>u32</code>): <code>PolkadotRuntimeParachainsAssignerCoretimeCoreDescriptor</code>",id:"coredescriptorsu32-polkadotruntimeparachainsassignercoretimecoredescriptor",level:3},{value:"coreSchedules(<code>(u32,u32)</code>): <code>Option&lt;PolkadotRuntimeParachainsAssignerCoretimeSchedule&gt;</code>",id:"coreschedulesu32u32-optionpolkadotruntimeparachainsassignercoretimeschedule",level:3},{value:"crowdloan",id:"crowdloan",level:2},{value:"endingsCount(): <code>u32</code>",id:"endingscount-u32",level:3},{value:"funds(<code>u32</code>): <code>Option&lt;PolkadotRuntimeCommonCrowdloanFundInfo&gt;</code>",id:"fundsu32-optionpolkadotruntimecommoncrowdloanfundinfo",level:3},{value:"newRaise(): <code>Vec&lt;u32&gt;</code>",id:"newraise-vecu32",level:3},{value:"nextFundIndex(): <code>u32</code>",id:"nextfundindex-u32",level:3},{value:"delegatedStaking",id:"delegatedstaking",level:2},{value:"agents(<code>AccountId32</code>): <code>Option&lt;PalletDelegatedStakingAgentLedger&gt;</code>",id:"agentsaccountid32-optionpalletdelegatedstakingagentledger",level:3},{value:"counterForAgents(): <code>u32</code>",id:"counterforagents-u32",level:3},{value:"counterForDelegators(): <code>u32</code>",id:"counterfordelegators-u32",level:3},{value:"delegators(<code>AccountId32</code>): <code>Option&lt;PalletDelegatedStakingDelegation&gt;</code>",id:"delegatorsaccountid32-optionpalletdelegatedstakingdelegation",level:3},{value:"dmp",id:"dmp",level:2},{value:"deliveryFeeFactor(<code>u32</code>): <code>u128</code>",id:"deliveryfeefactoru32-u128",level:3},{value:"downwardMessageQueueHeads(<code>u32</code>): <code>H256</code>",id:"downwardmessagequeueheadsu32-h256",level:3},{value:"downwardMessageQueues(<code>u32</code>): <code>Vec&lt;PolkadotCorePrimitivesInboundDownwardMessage&gt;</code>",id:"downwardmessagequeuesu32-vecpolkadotcoreprimitivesinbounddownwardmessage",level:3},{value:"electionProviderMultiPhase",id:"electionprovidermultiphase",level:2},{value:"currentPhase(): <code>PalletElectionProviderMultiPhasePhase</code>",id:"currentphase-palletelectionprovidermultiphasephase",level:3},{value:"desiredTargets(): <code>Option&lt;u32&gt;</code>",id:"desiredtargets-optionu32",level:3},{value:"minimumUntrustedScore(): <code>Option&lt;SpNposElectionsElectionScore&gt;</code>",id:"minimumuntrustedscore-optionspnposelectionselectionscore",level:3},{value:"queuedSolution(): <code>Option&lt;PalletElectionProviderMultiPhaseReadySolution&gt;</code>",id:"queuedsolution-optionpalletelectionprovidermultiphasereadysolution",level:3},{value:"round(): <code>u32</code>",id:"round-u32",level:3},{value:"signedSubmissionIndices(): <code>Vec&lt;(SpNposElectionsElectionScore,u32,u32)&gt;</code>",id:"signedsubmissionindices-vecspnposelectionselectionscoreu32u32",level:3},{value:"signedSubmissionNextIndex(): <code>u32</code>",id:"signedsubmissionnextindex-u32",level:3},{value:"signedSubmissionsMap(<code>u32</code>): <code>Option&lt;PalletElectionProviderMultiPhaseSignedSignedSubmission&gt;</code>",id:"signedsubmissionsmapu32-optionpalletelectionprovidermultiphasesignedsignedsubmission",level:3},{value:"snapshot(): <code>Option&lt;PalletElectionProviderMultiPhaseRoundSnapshot&gt;</code>",id:"snapshot-optionpalletelectionprovidermultiphaseroundsnapshot",level:3},{value:"snapshotMetadata(): <code>Option&lt;PalletElectionProviderMultiPhaseSolutionOrSnapshotSize&gt;</code>",id:"snapshotmetadata-optionpalletelectionprovidermultiphasesolutionorsnapshotsize",level:3},{value:"fastUnstake",id:"fastunstake",level:2},{value:"counterForQueue(): <code>u32</code>",id:"counterforqueue-u32",level:3},{value:"erasToCheckPerBlock(): <code>u32</code>",id:"erastocheckperblock-u32",level:3},{value:"head(): <code>Option&lt;PalletFastUnstakeUnstakeRequest&gt;</code>",id:"head-optionpalletfastunstakeunstakerequest",level:3},{value:"queue(<code>AccountId32</code>): <code>Option&lt;u128&gt;</code>",id:"queueaccountid32-optionu128",level:3},{value:"fellowshipCollective",id:"fellowshipcollective",level:2},{value:"idToIndex(<code>u16, AccountId32</code>): <code>Option&lt;u32&gt;</code>",id:"idtoindexu16-accountid32-optionu32",level:3},{value:"indexToId(<code>u16, u32</code>): <code>Option&lt;AccountId32&gt;</code>",id:"indextoidu16-u32-optionaccountid32",level:3},{value:"memberCount(<code>u16</code>): <code>u32</code>",id:"membercountu16-u32",level:3},{value:"members(<code>AccountId32</code>): <code>Option&lt;PalletRankedCollectiveMemberRecord&gt;</code>",id:"membersaccountid32-optionpalletrankedcollectivememberrecord",level:3},{value:"voting(<code>u32, AccountId32</code>): <code>Option&lt;PalletRankedCollectiveVoteRecord&gt;</code>",id:"votingu32-accountid32-optionpalletrankedcollectivevoterecord",level:3},{value:"votingCleanup(<code>u32</code>): <code>Option&lt;Bytes&gt;</code>",id:"votingcleanupu32-optionbytes",level:3},{value:"fellowshipReferenda",id:"fellowshipreferenda",level:2},{value:"decidingCount(<code>u16</code>): <code>u32</code>",id:"decidingcountu16-u32",level:3},{value:"metadataOf(<code>u32</code>): <code>Option&lt;H256&gt;</code>",id:"metadataofu32-optionh256",level:3},{value:"referendumCount(): <code>u32</code>",id:"referendumcount-u32",level:3},{value:"referendumInfoFor(<code>u32</code>): <code>Option&lt;PalletReferendaReferendumInfoRankedCollectiveTally&gt;</code>",id:"referenduminfoforu32-optionpalletreferendareferenduminforankedcollectivetally",level:3},{value:"trackQueue(<code>u16</code>): <code>Vec&lt;(u32,u32)&gt;</code>",id:"trackqueueu16-vecu32u32",level:3},{value:"grandpa",id:"grandpa",level:2},{value:"authorities(): <code>Vec&lt;(SpConsensusGrandpaAppPublic,u64)&gt;</code>",id:"authorities-vecspconsensusgrandpaapppublicu64",level:3},{value:"currentSetId(): <code>u64</code>",id:"currentsetid-u64",level:3},{value:"nextForced(): <code>Option&lt;u32&gt;</code>",id:"nextforced-optionu32",level:3},{value:"pendingChange(): <code>Option&lt;PalletGrandpaStoredPendingChange&gt;</code>",id:"pendingchange-optionpalletgrandpastoredpendingchange",level:3},{value:"setIdSession(<code>u64</code>): <code>Option&lt;u32&gt;</code>",id:"setidsessionu64-optionu32-1",level:3},{value:"stalled(): <code>Option&lt;(u32,u32)&gt;</code>",id:"stalled-optionu32u32",level:3},{value:"state(): <code>PalletGrandpaStoredState</code>",id:"state-palletgrandpastoredstate",level:3},{value:"historical",id:"historical",level:2},{value:"historicalSessions(<code>u32</code>): <code>Option&lt;(H256,u32)&gt;</code>",id:"historicalsessionsu32-optionh256u32",level:3},{value:"storedRange(): <code>Option&lt;(u32,u32)&gt;</code>",id:"storedrange-optionu32u32",level:3},{value:"hrmp",id:"hrmp",level:2},{value:"hrmpAcceptedChannelRequestCount(<code>u32</code>): <code>u32</code>",id:"hrmpacceptedchannelrequestcountu32-u32",level:3},{value:"hrmpChannelContents(<code>PolkadotParachainPrimitivesPrimitivesHrmpChannelId</code>): <code>Vec&lt;PolkadotCorePrimitivesInboundHrmpMessage&gt;</code>",id:"hrmpchannelcontentspolkadotparachainprimitivesprimitiveshrmpchannelid-vecpolkadotcoreprimitivesinboundhrmpmessage",level:3},{value:"hrmpChannelDigests(<code>u32</code>): <code>Vec&lt;(u32,Vec&lt;u32&gt;)&gt;</code>",id:"hrmpchanneldigestsu32-vecu32vecu32",level:3},{value:"hrmpChannels(<code>PolkadotParachainPrimitivesPrimitivesHrmpChannelId</code>): <code>Option&lt;PolkadotRuntimeParachainsHrmpHrmpChannel&gt;</code>",id:"hrmpchannelspolkadotparachainprimitivesprimitiveshrmpchannelid-optionpolkadotruntimeparachainshrmphrmpchannel",level:3},{value:"hrmpCloseChannelRequests(<code>PolkadotParachainPrimitivesPrimitivesHrmpChannelId</code>): <code>Option&lt;Null&gt;</code>",id:"hrmpclosechannelrequestspolkadotparachainprimitivesprimitiveshrmpchannelid-optionnull",level:3},{value:"hrmpCloseChannelRequestsList(): <code>Vec&lt;PolkadotParachainPrimitivesPrimitivesHrmpChannelId&gt;</code>",id:"hrmpclosechannelrequestslist-vecpolkadotparachainprimitivesprimitiveshrmpchannelid",level:3},{value:"hrmpEgressChannelsIndex(<code>u32</code>): <code>Vec&lt;u32&gt;</code>",id:"hrmpegresschannelsindexu32-vecu32",level:3},{value:"hrmpIngressChannelsIndex(<code>u32</code>): <code>Vec&lt;u32&gt;</code>",id:"hrmpingresschannelsindexu32-vecu32",level:3},{value:"hrmpOpenChannelRequestCount(<code>u32</code>): <code>u32</code>",id:"hrmpopenchannelrequestcountu32-u32",level:3},{value:"hrmpOpenChannelRequests(<code>PolkadotParachainPrimitivesPrimitivesHrmpChannelId</code>): <code>Option&lt;PolkadotRuntimeParachainsHrmpHrmpOpenChannelRequest&gt;</code>",id:"hrmpopenchannelrequestspolkadotparachainprimitivesprimitiveshrmpchannelid-optionpolkadotruntimeparachainshrmphrmpopenchannelrequest",level:3},{value:"hrmpOpenChannelRequestsList(): <code>Vec&lt;PolkadotParachainPrimitivesPrimitivesHrmpChannelId&gt;</code>",id:"hrmpopenchannelrequestslist-vecpolkadotparachainprimitivesprimitiveshrmpchannelid",level:3},{value:"hrmpWatermarks(<code>u32</code>): <code>Option&lt;u32&gt;</code>",id:"hrmpwatermarksu32-optionu32",level:3},{value:"indices",id:"indices",level:2},{value:"accounts(<code>u32</code>): <code>Option&lt;(AccountId32,u128,bool)&gt;</code>",id:"accountsu32-optionaccountid32u128bool",level:3},{value:"initializer",id:"initializer",level:2},{value:"bufferedSessionChanges(): <code>Vec&lt;PolkadotRuntimeParachainsInitializerBufferedSessionChange&gt;</code>",id:"bufferedsessionchanges-vecpolkadotruntimeparachainsinitializerbufferedsessionchange",level:3},{value:"hasInitialized(): <code>Option&lt;Null&gt;</code>",id:"hasinitialized-optionnull",level:3},{value:"messageQueue",id:"messagequeue",level:2},{value:"bookStateFor(<code>PolkadotRuntimeParachainsInclusionAggregateMessageOrigin</code>): <code>PalletMessageQueueBookState</code>",id:"bookstateforpolkadotruntimeparachainsinclusionaggregatemessageorigin-palletmessagequeuebookstate",level:3},{value:"pages(<code>PolkadotRuntimeParachainsInclusionAggregateMessageOrigin, u32</code>): <code>Option&lt;PalletMessageQueuePage&gt;</code>",id:"pagespolkadotruntimeparachainsinclusionaggregatemessageorigin-u32-optionpalletmessagequeuepage",level:3},{value:"serviceHead(): <code>Option&lt;PolkadotRuntimeParachainsInclusionAggregateMessageOrigin&gt;</code>",id:"servicehead-optionpolkadotruntimeparachainsinclusionaggregatemessageorigin",level:3},{value:"mmr",id:"mmr",level:2},{value:"nodes(<code>u64</code>): <code>Option&lt;H256&gt;</code>",id:"nodesu64-optionh256",level:3},{value:"numberOfLeaves(): <code>u64</code>",id:"numberofleaves-u64",level:3},{value:"rootHash(): <code>H256</code>",id:"roothash-h256",level:3},{value:"multisig",id:"multisig",level:2},{value:"multisigs(<code>AccountId32, [u8;32]</code>): <code>Option&lt;PalletMultisigMultisig&gt;</code>",id:"multisigsaccountid32-u832-optionpalletmultisigmultisig",level:3},{value:"nis",id:"nis",level:2},{value:"queues(<code>u32</code>): <code>Vec&lt;PalletNisBid&gt;</code>",id:"queuesu32-vecpalletnisbid",level:3},{value:"queueTotals(): <code>Vec&lt;(u32,u128)&gt;</code>",id:"queuetotals-vecu32u128",level:3},{value:"receipts(<code>u32</code>): <code>Option&lt;PalletNisReceiptRecord&gt;</code>",id:"receiptsu32-optionpalletnisreceiptrecord",level:3},{value:"summary(): <code>PalletNisSummaryRecord</code>",id:"summary-palletnissummaryrecord",level:3},{value:"nisCounterpartBalances",id:"niscounterpartbalances",level:2},{value:"account(<code>AccountId32</code>): <code>PalletBalancesAccountData</code>",id:"accountaccountid32-palletbalancesaccountdata-1",level:3},{value:"freezes(<code>AccountId32</code>): <code>Vec&lt;FrameSupportTokensMiscIdAmount&gt;</code>",id:"freezesaccountid32-vecframesupporttokensmiscidamount",level:3},{value:"holds(<code>AccountId32</code>): <code>Vec&lt;{&quot;id&quot;:&quot;StagingKusamaRuntimeRuntimeHoldReason&quot;,&quot;amount&quot;:&quot;u128&quot;}&gt;</code>",id:"holdsaccountid32-vecidstagingkusamaruntimeruntimeholdreasonamountu128-1",level:3},{value:"inactiveIssuance(): <code>u128</code>",id:"inactiveissuance-u128-1",level:3},{value:"locks(<code>AccountId32</code>): <code>Vec&lt;PalletBalancesBalanceLock&gt;</code>",id:"locksaccountid32-vecpalletbalancesbalancelock-1",level:3},{value:"reserves(<code>AccountId32</code>): <code>Vec&lt;PalletBalancesReserveData&gt;</code>",id:"reservesaccountid32-vecpalletbalancesreservedata-1",level:3},{value:"totalIssuance(): <code>u128</code>",id:"totalissuance-u128-1",level:3},{value:"nominationPools",id:"nominationpools",level:2},{value:"bondedPools(<code>u32</code>): <code>Option&lt;PalletNominationPoolsBondedPoolInner&gt;</code>",id:"bondedpoolsu32-optionpalletnominationpoolsbondedpoolinner",level:3},{value:"claimPermissions(<code>AccountId32</code>): <code>PalletNominationPoolsClaimPermission</code>",id:"claimpermissionsaccountid32-palletnominationpoolsclaimpermission",level:3},{value:"counterForBondedPools(): <code>u32</code>",id:"counterforbondedpools-u32",level:3},{value:"counterForMetadata(): <code>u32</code>",id:"counterformetadata-u32",level:3},{value:"counterForPoolMembers(): <code>u32</code>",id:"counterforpoolmembers-u32",level:3},{value:"counterForReversePoolIdLookup(): <code>u32</code>",id:"counterforreversepoolidlookup-u32",level:3},{value:"counterForRewardPools(): <code>u32</code>",id:"counterforrewardpools-u32",level:3},{value:"counterForSubPoolsStorage(): <code>u32</code>",id:"counterforsubpoolsstorage-u32",level:3},{value:"globalMaxCommission(): <code>Option&lt;Perbill&gt;</code>",id:"globalmaxcommission-optionperbill",level:3},{value:"lastPoolId(): <code>u32</code>",id:"lastpoolid-u32",level:3},{value:"maxPoolMembers(): <code>Option&lt;u32&gt;</code>",id:"maxpoolmembers-optionu32",level:3},{value:"maxPoolMembersPerPool(): <code>Option&lt;u32&gt;</code>",id:"maxpoolmembersperpool-optionu32",level:3},{value:"maxPools(): <code>Option&lt;u32&gt;</code>",id:"maxpools-optionu32",level:3},{value:"metadata(<code>u32</code>): <code>Bytes</code>",id:"metadatau32-bytes",level:3},{value:"minCreateBond(): <code>u128</code>",id:"mincreatebond-u128",level:3},{value:"minJoinBond(): <code>u128</code>",id:"minjoinbond-u128",level:3},{value:"poolMembers(<code>AccountId32</code>): <code>Option&lt;PalletNominationPoolsPoolMember&gt;</code>",id:"poolmembersaccountid32-optionpalletnominationpoolspoolmember",level:3},{value:"reversePoolIdLookup(<code>AccountId32</code>): <code>Option&lt;u32&gt;</code>",id:"reversepoolidlookupaccountid32-optionu32",level:3},{value:"rewardPools(<code>u32</code>): <code>Option&lt;PalletNominationPoolsRewardPool&gt;</code>",id:"rewardpoolsu32-optionpalletnominationpoolsrewardpool",level:3},{value:"subPoolsStorage(<code>u32</code>): <code>Option&lt;PalletNominationPoolsSubPools&gt;</code>",id:"subpoolsstorageu32-optionpalletnominationpoolssubpools",level:3},{value:"totalValueLocked(): <code>u128</code>",id:"totalvaluelocked-u128",level:3},{value:"offences",id:"offences",level:2},{value:"concurrentReportsIndex(<code>[u8;16], Bytes</code>): <code>Vec&lt;H256&gt;</code>",id:"concurrentreportsindexu816-bytes-vech256",level:3},{value:"reports(<code>H256</code>): <code>Option&lt;SpStakingOffenceOffenceDetails&gt;</code>",id:"reportsh256-optionspstakingoffenceoffencedetails",level:3},{value:"onDemandAssignmentProvider",id:"ondemandassignmentprovider",level:2},{value:"affinityEntries(<code>u32</code>): <code>BinaryHeapEnqueuedOrder</code>",id:"affinityentriesu32-binaryheapenqueuedorder",level:3},{value:"credits(<code>AccountId32</code>): <code>u128</code>",id:"creditsaccountid32-u128",level:3},{value:"freeEntries(): <code>BinaryHeapEnqueuedOrder</code>",id:"freeentries-binaryheapenqueuedorder",level:3},{value:"paraIdAffinity(<code>u32</code>): <code>Option&lt;PolkadotRuntimeParachainsOnDemandTypesCoreAffinityCount&gt;</code>",id:"paraidaffinityu32-optionpolkadotruntimeparachainsondemandtypescoreaffinitycount",level:3},{value:"queueStatus(): <code>PolkadotRuntimeParachainsOnDemandTypesQueueStatusType</code>",id:"queuestatus-polkadotruntimeparachainsondemandtypesqueuestatustype",level:3},{value:"revenue(): <code>Vec&lt;u128&gt;</code>",id:"revenue-vecu128",level:3},{value:"paraInclusion",id:"parainclusion",level:2},{value:"v1(<code>u32</code>): <code>Option&lt;Vec&lt;PolkadotRuntimeParachainsInclusionCandidatePendingAvailability&gt;&gt;</code>",id:"v1u32-optionvecpolkadotruntimeparachainsinclusioncandidatependingavailability",level:3},{value:"paraInherent",id:"parainherent",level:2},{value:"included(): <code>Option&lt;Null&gt;</code>",id:"included-optionnull",level:3},{value:"onChainVotes(): <code>Option&lt;PolkadotPrimitivesVstagingScrapedOnChainVotes&gt;</code>",id:"onchainvotes-optionpolkadotprimitivesvstagingscrapedonchainvotes",level:3},{value:"parameters",id:"parameters",level:2},{value:"parameters(<code>StagingKusamaRuntimeRuntimeParametersKey</code>): <code>Option&lt;StagingKusamaRuntimeRuntimeParametersValue&gt;</code>",id:"parametersstagingkusamaruntimeruntimeparameterskey-optionstagingkusamaruntimeruntimeparametersvalue",level:3},{value:"paras",id:"paras",level:2},{value:"actionsQueue(<code>u32</code>): <code>Vec&lt;u32&gt;</code>",id:"actionsqueueu32-vecu32",level:3},{value:"codeByHash(<code>H256</code>): <code>Option&lt;Bytes&gt;</code>",id:"codebyhashh256-optionbytes",level:3},{value:"codeByHashRefs(<code>H256</code>): <code>u32</code>",id:"codebyhashrefsh256-u32",level:3},{value:"currentCodeHash(<code>u32</code>): <code>Option&lt;H256&gt;</code>",id:"currentcodehashu32-optionh256",level:3},{value:"futureCodeHash(<code>u32</code>): <code>Option&lt;H256&gt;</code>",id:"futurecodehashu32-optionh256",level:3},{value:"futureCodeUpgrades(<code>u32</code>): <code>Option&lt;u32&gt;</code>",id:"futurecodeupgradesu32-optionu32",level:3},{value:"futureCodeUpgradesAt(): <code>Vec&lt;(u32,u32)&gt;</code>",id:"futurecodeupgradesat-vecu32u32",level:3},{value:"heads(<code>u32</code>): <code>Option&lt;Bytes&gt;</code>",id:"headsu32-optionbytes",level:3},{value:"mostRecentContext(<code>u32</code>): <code>Option&lt;u32&gt;</code>",id:"mostrecentcontextu32-optionu32",level:3},{value:"parachains(): <code>Vec&lt;u32&gt;</code>",id:"parachains-vecu32",level:3},{value:"paraLifecycles(<code>u32</code>): <code>Option&lt;PolkadotRuntimeParachainsParasParaLifecycle&gt;</code>",id:"paralifecyclesu32-optionpolkadotruntimeparachainsparasparalifecycle",level:3},{value:"pastCodeHash(<code>(u32,u32)</code>): <code>Option&lt;H256&gt;</code>",id:"pastcodehashu32u32-optionh256",level:3},{value:"pastCodeMeta(<code>u32</code>): <code>PolkadotRuntimeParachainsParasParaPastCodeMeta</code>",id:"pastcodemetau32-polkadotruntimeparachainsparasparapastcodemeta",level:3},{value:"pastCodePruning(): <code>Vec&lt;(u32,u32)&gt;</code>",id:"pastcodepruning-vecu32u32",level:3},{value:"pvfActiveVoteList(): <code>Vec&lt;H256&gt;</code>",id:"pvfactivevotelist-vech256",level:3},{value:"pvfActiveVoteMap(<code>H256</code>): <code>Option&lt;PolkadotRuntimeParachainsParasPvfCheckActiveVoteState&gt;</code>",id:"pvfactivevotemaph256-optionpolkadotruntimeparachainsparaspvfcheckactivevotestate",level:3},{value:"upcomingParasGenesis(<code>u32</code>): <code>Option&lt;PolkadotRuntimeParachainsParasParaGenesisArgs&gt;</code>",id:"upcomingparasgenesisu32-optionpolkadotruntimeparachainsparasparagenesisargs",level:3},{value:"upcomingUpgrades(): <code>Vec&lt;(u32,u32)&gt;</code>",id:"upcomingupgrades-vecu32u32",level:3},{value:"upgradeCooldowns(): <code>Vec&lt;(u32,u32)&gt;</code>",id:"upgradecooldowns-vecu32u32",level:3},{value:"upgradeGoAheadSignal(<code>u32</code>): <code>Option&lt;PolkadotPrimitivesV8UpgradeGoAhead&gt;</code>",id:"upgradegoaheadsignalu32-optionpolkadotprimitivesv8upgradegoahead",level:3},{value:"upgradeRestrictionSignal(<code>u32</code>): <code>Option&lt;PolkadotPrimitivesV8UpgradeRestriction&gt;</code>",id:"upgraderestrictionsignalu32-optionpolkadotprimitivesv8upgraderestriction",level:3},{value:"paraScheduler",id:"parascheduler",level:2},{value:"claimQueue(): <code>BTreeMap&lt;u32, Vec&lt;PolkadotRuntimeParachainsSchedulerCommonAssignment&gt;&gt;</code>",id:"claimqueue-btreemapu32-vecpolkadotruntimeparachainsschedulercommonassignment",level:3},{value:"sessionStartBlock(): <code>u32</code>",id:"sessionstartblock-u32",level:3},{value:"validatorGroups(): <code>Vec&lt;Vec&lt;u32&gt;&gt;</code>",id:"validatorgroups-vecvecu32",level:3},{value:"parasDisputes",id:"parasdisputes",level:2},{value:"backersOnDisputes(<code>u32, H256</code>): <code>Option&lt;BTreeSet&lt;u32&gt;&gt;</code>",id:"backersondisputesu32-h256-optionbtreesetu32",level:3},{value:"disputes(<code>u32, H256</code>): <code>Option&lt;PolkadotPrimitivesV8DisputeState&gt;</code>",id:"disputesu32-h256-optionpolkadotprimitivesv8disputestate",level:3},{value:"frozen(): <code>Option&lt;u32&gt;</code>",id:"frozen-optionu32",level:3},{value:"included(<code>u32, H256</code>): <code>Option&lt;u32&gt;</code>",id:"includedu32-h256-optionu32",level:3},{value:"lastPrunedSession(): <code>Option&lt;u32&gt;</code>",id:"lastprunedsession-optionu32",level:3},{value:"paraSessionInfo",id:"parasessioninfo",level:2},{value:"accountKeys(<code>u32</code>): <code>Option&lt;Vec&lt;AccountId32&gt;&gt;</code>",id:"accountkeysu32-optionvecaccountid32",level:3},{value:"assignmentKeysUnsafe(): <code>Vec&lt;PolkadotPrimitivesV8AssignmentAppPublic&gt;</code>",id:"assignmentkeysunsafe-vecpolkadotprimitivesv8assignmentapppublic",level:3},{value:"earliestStoredSession(): <code>u32</code>",id:"earlieststoredsession-u32",level:3},{value:"sessionExecutorParams(<code>u32</code>): <code>Option&lt;PolkadotPrimitivesV8ExecutorParams&gt;</code>",id:"sessionexecutorparamsu32-optionpolkadotprimitivesv8executorparams",level:3},{value:"sessions(<code>u32</code>): <code>Option&lt;PolkadotPrimitivesV8SessionInfo&gt;</code>",id:"sessionsu32-optionpolkadotprimitivesv8sessioninfo",level:3},{value:"parasShared",id:"parasshared",level:2},{value:"activeValidatorIndices(): <code>Vec&lt;u32&gt;</code>",id:"activevalidatorindices-vecu32",level:3},{value:"activeValidatorKeys(): <code>Vec&lt;PolkadotPrimitivesV8ValidatorAppPublic&gt;</code>",id:"activevalidatorkeys-vecpolkadotprimitivesv8validatorapppublic",level:3},{value:"allowedRelayParents(): <code>PolkadotRuntimeParachainsSharedAllowedRelayParentsTracker</code>",id:"allowedrelayparents-polkadotruntimeparachainssharedallowedrelayparentstracker",level:3},{value:"currentSessionIndex(): <code>u32</code>",id:"currentsessionindex-u32",level:3},{value:"parasSlashing",id:"parasslashing",level:2},{value:"unappliedSlashes(<code>u32, H256</code>): <code>Option&lt;PolkadotPrimitivesV8SlashingPendingSlashes&gt;</code>",id:"unappliedslashesu32-h256-optionpolkadotprimitivesv8slashingpendingslashes",level:3},{value:"validatorSetCounts(<code>u32</code>): <code>Option&lt;u32&gt;</code>",id:"validatorsetcountsu32-optionu32",level:3},{value:"preimage",id:"preimage",level:2},{value:"preimageFor(<code>(H256,u32)</code>): <code>Option&lt;Bytes&gt;</code>",id:"preimageforh256u32-optionbytes",level:3},{value:"requestStatusFor(<code>H256</code>): <code>Option&lt;PalletPreimageRequestStatus&gt;</code>",id:"requeststatusforh256-optionpalletpreimagerequeststatus",level:3},{value:"statusFor(<code>H256</code>): <code>Option&lt;PalletPreimageOldRequestStatus&gt;</code>",id:"statusforh256-optionpalletpreimageoldrequeststatus",level:3},{value:"proxy",id:"proxy",level:2},{value:"announcements(<code>AccountId32</code>): <code>(Vec&lt;PalletProxyAnnouncement&gt;,u128)</code>",id:"announcementsaccountid32-vecpalletproxyannouncementu128",level:3},{value:"proxies(<code>AccountId32</code>): <code>(Vec&lt;PalletProxyProxyDefinition&gt;,u128)</code>",id:"proxiesaccountid32-vecpalletproxyproxydefinitionu128",level:3},{value:"recovery",id:"recovery",level:2},{value:"activeRecoveries(<code>AccountId32, AccountId32</code>): <code>Option&lt;PalletRecoveryActiveRecovery&gt;</code>",id:"activerecoveriesaccountid32-accountid32-optionpalletrecoveryactiverecovery",level:3},{value:"proxy(<code>AccountId32</code>): <code>Option&lt;AccountId32&gt;</code>",id:"proxyaccountid32-optionaccountid32",level:3},{value:"recoverable(<code>AccountId32</code>): <code>Option&lt;PalletRecoveryRecoveryConfig&gt;</code>",id:"recoverableaccountid32-optionpalletrecoveryrecoveryconfig",level:3},{value:"referenda",id:"referenda",level:2},{value:"decidingCount(<code>u16</code>): <code>u32</code>",id:"decidingcountu16-u32-1",level:3},{value:"metadataOf(<code>u32</code>): <code>Option&lt;H256&gt;</code>",id:"metadataofu32-optionh256-1",level:3},{value:"referendumCount(): <code>u32</code>",id:"referendumcount-u32-1",level:3},{value:"referendumInfoFor(<code>u32</code>): <code>Option&lt;PalletReferendaReferendumInfoConvictionVotingTally&gt;</code>",id:"referenduminfoforu32-optionpalletreferendareferenduminfoconvictionvotingtally",level:3},{value:"trackQueue(<code>u16</code>): <code>Vec&lt;(u32,u128)&gt;</code>",id:"trackqueueu16-vecu32u128",level:3},{value:"registrar",id:"registrar",level:2},{value:"nextFreeParaId(): <code>u32</code>",id:"nextfreeparaid-u32",level:3},{value:"paras(<code>u32</code>): <code>Option&lt;PolkadotRuntimeCommonParasRegistrarParaInfo&gt;</code>",id:"parasu32-optionpolkadotruntimecommonparasregistrarparainfo",level:3},{value:"pendingSwap(<code>u32</code>): <code>Option&lt;u32&gt;</code>",id:"pendingswapu32-optionu32",level:3},{value:"scheduler",id:"scheduler",level:2},{value:"agenda(<code>u32</code>): <code>Vec&lt;Option&lt;PalletSchedulerScheduled&gt;&gt;</code>",id:"agendau32-vecoptionpalletschedulerscheduled",level:3},{value:"incompleteSince(): <code>Option&lt;u32&gt;</code>",id:"incompletesince-optionu32",level:3},{value:"lookup(<code>[u8;32]</code>): <code>Option&lt;(u32,u32)&gt;</code>",id:"lookupu832-optionu32u32",level:3},{value:"retries(<code>(u32,u32)</code>): <code>Option&lt;PalletSchedulerRetryConfig&gt;</code>",id:"retriesu32u32-optionpalletschedulerretryconfig",level:3},{value:"session",id:"session",level:2},{value:"currentIndex(): <code>u32</code>",id:"currentindex-u32",level:3},{value:"disabledValidators(): <code>Vec&lt;(u32,Perbill)&gt;</code>",id:"disabledvalidators-vecu32perbill",level:3},{value:"keyOwner(<code>(SpCoreCryptoKeyTypeId,Bytes)</code>): <code>Option&lt;AccountId32&gt;</code>",id:"keyownerspcorecryptokeytypeidbytes-optionaccountid32",level:3},{value:"nextKeys(<code>AccountId32</code>): <code>Option&lt;StagingKusamaRuntimeSessionKeys&gt;</code>",id:"nextkeysaccountid32-optionstagingkusamaruntimesessionkeys",level:3},{value:"queuedChanged(): <code>bool</code>",id:"queuedchanged-bool",level:3},{value:"queuedKeys(): <code>Vec&lt;(AccountId32,StagingKusamaRuntimeSessionKeys)&gt;</code>",id:"queuedkeys-vecaccountid32stagingkusamaruntimesessionkeys",level:3},{value:"validators(): <code>Vec&lt;AccountId32&gt;</code>",id:"validators-vecaccountid32",level:3},{value:"slots",id:"slots",level:2},{value:"leases(<code>u32</code>): <code>Vec&lt;Option&lt;(AccountId32,u128)&gt;&gt;</code>",id:"leasesu32-vecoptionaccountid32u128",level:3},{value:"society",id:"society",level:2},{value:"bids(): <code>Vec&lt;PalletSocietyBid&gt;</code>",id:"bids-vecpalletsocietybid",level:3},{value:"candidates(<code>AccountId32</code>): <code>Option&lt;PalletSocietyCandidacy&gt;</code>",id:"candidatesaccountid32-optionpalletsocietycandidacy",level:3},{value:"challengeRoundCount(): <code>u32</code>",id:"challengeroundcount-u32",level:3},{value:"defenderVotes(<code>u32, AccountId32</code>): <code>Option&lt;PalletSocietyVote&gt;</code>",id:"defendervotesu32-accountid32-optionpalletsocietyvote",level:3},{value:"defending(): <code>Option&lt;(AccountId32,AccountId32,PalletSocietyTally)&gt;</code>",id:"defending-optionaccountid32accountid32palletsocietytally",level:3},{value:"founder(): <code>Option&lt;AccountId32&gt;</code>",id:"founder-optionaccountid32",level:3},{value:"head(): <code>Option&lt;AccountId32&gt;</code>",id:"head-optionaccountid32",level:3},{value:"memberByIndex(<code>u32</code>): <code>Option&lt;AccountId32&gt;</code>",id:"memberbyindexu32-optionaccountid32",level:3},{value:"memberCount(): <code>u32</code>",id:"membercount-u32",level:3},{value:"members(<code>AccountId32</code>): <code>Option&lt;PalletSocietyMemberRecord&gt;</code>",id:"membersaccountid32-optionpalletsocietymemberrecord",level:3},{value:"nextHead(): <code>Option&lt;PalletSocietyIntakeRecord&gt;</code>",id:"nexthead-optionpalletsocietyintakerecord",level:3},{value:"parameters(): <code>Option&lt;PalletSocietyGroupParams&gt;</code>",id:"parameters-optionpalletsocietygroupparams",level:3},{value:"payouts(<code>AccountId32</code>): <code>PalletSocietyPayoutRecord</code>",id:"payoutsaccountid32-palletsocietypayoutrecord",level:3},{value:"pot(): <code>u128</code>",id:"pot-u128",level:3},{value:"roundCount(): <code>u32</code>",id:"roundcount-u32",level:3},{value:"rules(): <code>Option&lt;H256&gt;</code>",id:"rules-optionh256",level:3},{value:"skeptic(): <code>Option&lt;AccountId32&gt;</code>",id:"skeptic-optionaccountid32",level:3},{value:"suspendedMembers(<code>AccountId32</code>): <code>Option&lt;PalletSocietyMemberRecord&gt;</code>",id:"suspendedmembersaccountid32-optionpalletsocietymemberrecord",level:3},{value:"voteClearCursor(<code>AccountId32</code>): <code>Option&lt;Bytes&gt;</code>",id:"voteclearcursoraccountid32-optionbytes",level:3},{value:"votes(<code>AccountId32, AccountId32</code>): <code>Option&lt;PalletSocietyVote&gt;</code>",id:"votesaccountid32-accountid32-optionpalletsocietyvote",level:3},{value:"staking",id:"staking",level:2},{value:"activeEra(): <code>Option&lt;PalletStakingActiveEraInfo&gt;</code>",id:"activeera-optionpalletstakingactiveerainfo",level:3},{value:"bonded(<code>AccountId32</code>): <code>Option&lt;AccountId32&gt;</code>",id:"bondedaccountid32-optionaccountid32",level:3},{value:"bondedEras(): <code>Vec&lt;(u32,u32)&gt;</code>",id:"bondederas-vecu32u32",level:3},{value:"canceledSlashPayout(): <code>u128</code>",id:"canceledslashpayout-u128",level:3},{value:"chillThreshold(): <code>Option&lt;Percent&gt;</code>",id:"chillthreshold-optionpercent",level:3},{value:"claimedRewards(<code>u32, AccountId32</code>): <code>Vec&lt;u32&gt;</code>",id:"claimedrewardsu32-accountid32-vecu32",level:3},{value:"counterForNominators(): <code>u32</code>",id:"counterfornominators-u32",level:3},{value:"counterForValidators(): <code>u32</code>",id:"counterforvalidators-u32",level:3},{value:"counterForVirtualStakers(): <code>u32</code>",id:"counterforvirtualstakers-u32",level:3},{value:"currentEra(): <code>Option&lt;u32&gt;</code>",id:"currentera-optionu32",level:3},{value:"currentPlannedSession(): <code>u32</code>",id:"currentplannedsession-u32",level:3},{value:"erasRewardPoints(<code>u32</code>): <code>PalletStakingEraRewardPoints</code>",id:"erasrewardpointsu32-palletstakingerarewardpoints",level:3},{value:"erasStakers(<code>u32, AccountId32</code>): <code>SpStakingExposure</code>",id:"erasstakersu32-accountid32-spstakingexposure",level:3},{value:"erasStakersClipped(<code>u32, AccountId32</code>): <code>SpStakingExposure</code>",id:"erasstakersclippedu32-accountid32-spstakingexposure",level:3},{value:"erasStakersOverview(<code>u32, AccountId32</code>): <code>Option&lt;SpStakingPagedExposureMetadata&gt;</code>",id:"erasstakersoverviewu32-accountid32-optionspstakingpagedexposuremetadata",level:3},{value:"erasStakersPaged(<code>u32, AccountId32, u32</code>): <code>Option&lt;SpStakingExposurePage&gt;</code>",id:"erasstakerspagedu32-accountid32-u32-optionspstakingexposurepage",level:3},{value:"erasStartSessionIndex(<code>u32</code>): <code>Option&lt;u32&gt;</code>",id:"erasstartsessionindexu32-optionu32",level:3},{value:"erasTotalStake(<code>u32</code>): <code>u128</code>",id:"erastotalstakeu32-u128",level:3},{value:"erasValidatorPrefs(<code>u32, AccountId32</code>): <code>PalletStakingValidatorPrefs</code>",id:"erasvalidatorprefsu32-accountid32-palletstakingvalidatorprefs",level:3},{value:"erasValidatorReward(<code>u32</code>): <code>Option&lt;u128&gt;</code>",id:"erasvalidatorrewardu32-optionu128",level:3},{value:"forceEra(): <code>PalletStakingForcing</code>",id:"forceera-palletstakingforcing",level:3},{value:"invulnerables(): <code>Vec&lt;AccountId32&gt;</code>",id:"invulnerables-vecaccountid32",level:3},{value:"ledger(<code>AccountId32</code>): <code>Option&lt;PalletStakingStakingLedger&gt;</code>",id:"ledgeraccountid32-optionpalletstakingstakingledger",level:3},{value:"maxNominatorsCount(): <code>Option&lt;u32&gt;</code>",id:"maxnominatorscount-optionu32",level:3},{value:"maxStakedRewards(): <code>Option&lt;Percent&gt;</code>",id:"maxstakedrewards-optionpercent",level:3},{value:"maxValidatorsCount(): <code>Option&lt;u32&gt;</code>",id:"maxvalidatorscount-optionu32",level:3},{value:"minCommission(): <code>Perbill</code>",id:"mincommission-perbill",level:3},{value:"minimumActiveStake(): <code>u128</code>",id:"minimumactivestake-u128",level:3},{value:"minimumValidatorCount(): <code>u32</code>",id:"minimumvalidatorcount-u32",level:3},{value:"minNominatorBond(): <code>u128</code>",id:"minnominatorbond-u128",level:3},{value:"minValidatorBond(): <code>u128</code>",id:"minvalidatorbond-u128",level:3},{value:"nominators(<code>AccountId32</code>): <code>Option&lt;PalletStakingNominations&gt;</code>",id:"nominatorsaccountid32-optionpalletstakingnominations",level:3},{value:"nominatorSlashInEra(<code>u32, AccountId32</code>): <code>Option&lt;u128&gt;</code>",id:"nominatorslashinerau32-accountid32-optionu128",level:3},{value:"payee(<code>AccountId32</code>): <code>Option&lt;PalletStakingRewardDestination&gt;</code>",id:"payeeaccountid32-optionpalletstakingrewarddestination",level:3},{value:"slashingSpans(<code>AccountId32</code>): <code>Option&lt;PalletStakingSlashingSlashingSpans&gt;</code>",id:"slashingspansaccountid32-optionpalletstakingslashingslashingspans",level:3},{value:"slashRewardFraction(): <code>Perbill</code>",id:"slashrewardfraction-perbill",level:3},{value:"spanSlash(<code>(AccountId32,u32)</code>): <code>PalletStakingSlashingSpanRecord</code>",id:"spanslashaccountid32u32-palletstakingslashingspanrecord",level:3},{value:"unappliedSlashes(<code>u32</code>): <code>Vec&lt;PalletStakingUnappliedSlash&gt;</code>",id:"unappliedslashesu32-vecpalletstakingunappliedslash",level:3},{value:"validatorCount(): <code>u32</code>",id:"validatorcount-u32",level:3},{value:"validators(<code>AccountId32</code>): <code>PalletStakingValidatorPrefs</code>",id:"validatorsaccountid32-palletstakingvalidatorprefs",level:3},{value:"validatorSlashInEra(<code>u32, AccountId32</code>): <code>Option&lt;(Perbill,u128)&gt;</code>",id:"validatorslashinerau32-accountid32-optionperbillu128",level:3},{value:"virtualStakers(<code>AccountId32</code>): <code>Option&lt;Null&gt;</code>",id:"virtualstakersaccountid32-optionnull",level:3},{value:"substrate",id:"substrate",level:2},{value:"changesTrieConfig(): <code>u32</code>",id:"changestrieconfig-u32",level:3},{value:"childStorageKeyPrefix(): <code>u32</code>",id:"childstoragekeyprefix-u32",level:3},{value:"code(): <code>Bytes</code>",id:"code-bytes",level:3},{value:"defaultChildStorageKeyPrefix(): <code>u32</code>",id:"defaultchildstoragekeyprefix-u32",level:3},{value:"extrinsicIndex(): <code>u32</code>",id:"extrinsicindex-u32",level:3},{value:"heapPages(): <code>u64</code>",id:"heappages-u64",level:3},{value:"intrablockEntropy(): <code>[u8;32]</code>",id:"intrablockentropy-u832",level:3},{value:"storageVersionStorageKeyPostfix(): <code>u16</code>",id:"storageversionstoragekeypostfix-u16",level:3},{value:"transactionLevelKey(): <code>u32</code>",id:"transactionlevelkey-u32",level:3},{value:"system",id:"system",level:2},{value:"account(<code>AccountId32</code>): <code>FrameSystemAccountInfo</code>",id:"accountaccountid32-framesystemaccountinfo",level:3},{value:"allExtrinsicsLen(): <code>Option&lt;u32&gt;</code>",id:"allextrinsicslen-optionu32",level:3},{value:"authorizedUpgrade(): <code>Option&lt;FrameSystemCodeUpgradeAuthorization&gt;</code>",id:"authorizedupgrade-optionframesystemcodeupgradeauthorization",level:3},{value:"blockHash(<code>u32</code>): <code>H256</code>",id:"blockhashu32-h256",level:3},{value:"blockWeight(): <code>FrameSupportDispatchPerDispatchClassWeight</code>",id:"blockweight-framesupportdispatchperdispatchclassweight",level:3},{value:"digest(): <code>SpRuntimeDigest</code>",id:"digest-spruntimedigest",level:3},{value:"eventCount(): <code>u32</code>",id:"eventcount-u32",level:3},{value:"events(): <code>Vec&lt;FrameSystemEventRecord&gt;</code>",id:"events-vecframesystemeventrecord",level:3},{value:"eventTopics(<code>H256</code>): <code>Vec&lt;(u32,u32)&gt;</code>",id:"eventtopicsh256-vecu32u32",level:3},{value:"executionPhase(): <code>Option&lt;FrameSystemPhase&gt;</code>",id:"executionphase-optionframesystemphase",level:3},{value:"extrinsicCount(): <code>Option&lt;u32&gt;</code>",id:"extrinsiccount-optionu32",level:3},{value:"extrinsicData(<code>u32</code>): <code>Bytes</code>",id:"extrinsicdatau32-bytes",level:3},{value:"extrinsicWeightReclaimed(): <code>SpWeightsWeightV2Weight</code>",id:"extrinsicweightreclaimed-spweightsweightv2weight",level:3},{value:"inherentsApplied(): <code>bool</code>",id:"inherentsapplied-bool",level:3},{value:"lastRuntimeUpgrade(): <code>Option&lt;FrameSystemLastRuntimeUpgradeInfo&gt;</code>",id:"lastruntimeupgrade-optionframesystemlastruntimeupgradeinfo",level:3},{value:"number(): <code>u32</code>",id:"number-u32",level:3},{value:"parentHash(): <code>H256</code>",id:"parenthash-h256",level:3},{value:"upgradedToTripleRefCount(): <code>bool</code>",id:"upgradedtotriplerefcount-bool",level:3},{value:"upgradedToU32RefCount(): <code>bool</code>",id:"upgradedtou32refcount-bool",level:3},{value:"timestamp",id:"timestamp",level:2},{value:"didUpdate(): <code>bool</code>",id:"didupdate-bool",level:3},{value:"now(): <code>u64</code>",id:"now-u64",level:3},{value:"transactionPayment",id:"transactionpayment",level:2},{value:"nextFeeMultiplier(): <code>u128</code>",id:"nextfeemultiplier-u128",level:3},{value:"storageVersion(): <code>PalletTransactionPaymentReleases</code>",id:"storageversion-pallettransactionpaymentreleases",level:3},{value:"treasury",id:"treasury",level:2},{value:"approvals(): <code>Vec&lt;u32&gt;</code>",id:"approvals-vecu32",level:3},{value:"deactivated(): <code>u128</code>",id:"deactivated-u128",level:3},{value:"lastSpendPeriod(): <code>Option&lt;u32&gt;</code>",id:"lastspendperiod-optionu32",level:3},{value:"proposalCount(): <code>u32</code>",id:"proposalcount-u32",level:3},{value:"proposals(<code>u32</code>): <code>Option&lt;PalletTreasuryProposal&gt;</code>",id:"proposalsu32-optionpallettreasuryproposal",level:3},{value:"spendCount(): <code>u32</code>",id:"spendcount-u32",level:3},{value:"spends(<code>u32</code>): <code>Option&lt;PalletTreasurySpendStatus&gt;</code>",id:"spendsu32-optionpallettreasuryspendstatus",level:3},{value:"vesting",id:"vesting",level:2},{value:"storageVersion(): <code>PalletVestingReleases</code>",id:"storageversion-palletvestingreleases",level:3},{value:"vesting(<code>AccountId32</code>): <code>Option&lt;Vec&lt;PalletVestingVestingInfo&gt;&gt;</code>",id:"vestingaccountid32-optionvecpalletvestingvestinginfo",level:3},{value:"voterList",id:"voterlist",level:2},{value:"counterForListNodes(): <code>u32</code>",id:"counterforlistnodes-u32",level:3},{value:"listBags(<code>u64</code>): <code>Option&lt;PalletBagsListListBag&gt;</code>",id:"listbagsu64-optionpalletbagslistlistbag",level:3},{value:"listNodes(<code>AccountId32</code>): <code>Option&lt;PalletBagsListListNode&gt;</code>",id:"listnodesaccountid32-optionpalletbagslistlistnode",level:3},{value:"whitelist",id:"whitelist",level:2},{value:"whitelistedCall(<code>H256</code>): <code>Option&lt;Null&gt;</code>",id:"whitelistedcallh256-optionnull",level:3},{value:"xcmPallet",id:"xcmpallet",level:2},{value:"assetTraps(<code>H256</code>): <code>u32</code>",id:"assettrapsh256-u32",level:3},{value:"authorizedAliases(<code>XcmVersionedLocation</code>): <code>Option&lt;PalletXcmAuthorizedAliasesEntry&gt;</code>",id:"authorizedaliasesxcmversionedlocation-optionpalletxcmauthorizedaliasesentry",level:3},{value:"currentMigration(): <code>Option&lt;PalletXcmVersionMigrationStage&gt;</code>",id:"currentmigration-optionpalletxcmversionmigrationstage",level:3},{value:"lockedFungibles(<code>AccountId32</code>): <code>Option&lt;Vec&lt;(u128,XcmVersionedLocation)&gt;&gt;</code>",id:"lockedfungiblesaccountid32-optionvecu128xcmversionedlocation",level:3},{value:"queries(<code>u64</code>): <code>Option&lt;PalletXcmQueryStatus&gt;</code>",id:"queriesu64-optionpalletxcmquerystatus",level:3},{value:"queryCounter(): <code>u64</code>",id:"querycounter-u64",level:3},{value:"recordedXcm(): <code>Option&lt;StagingXcmV5Xcm&gt;</code>",id:"recordedxcm-optionstagingxcmv5xcm",level:3},{value:"remoteLockedFungibles(<code>u32, AccountId32, XcmVersionedAssetId</code>): <code>Option&lt;PalletXcmRemoteLockedFungibleRecord&gt;</code>",id:"remotelockedfungiblesu32-accountid32-xcmversionedassetid-optionpalletxcmremotelockedfungiblerecord",level:3},{value:"safeXcmVersion(): <code>Option&lt;u32&gt;</code>",id:"safexcmversion-optionu32",level:3},{value:"shouldRecordXcm(): <code>bool</code>",id:"shouldrecordxcm-bool",level:3},{value:"supportedVersion(<code>u32, XcmVersionedLocation</code>): <code>Option&lt;u32&gt;</code>",id:"supportedversionu32-xcmversionedlocation-optionu32",level:3},{value:"versionDiscoveryQueue(): <code>Vec&lt;(XcmVersionedLocation,u32)&gt;</code>",id:"versiondiscoveryqueue-vecxcmversionedlocationu32",level:3},{value:"versionNotifiers(<code>u32, XcmVersionedLocation</code>): <code>Option&lt;u64&gt;</code>",id:"versionnotifiersu32-xcmversionedlocation-optionu64",level:3},{value:"versionNotifyTargets(<code>u32, XcmVersionedLocation</code>): <code>Option&lt;(u64,SpWeightsWeightV2Weight,u32)&gt;</code>",id:"versionnotifytargetsu32-xcmversionedlocation-optionu64spweightsweightv2weightu32",level:3},{value:"xcmExecutionSuspended(): <code>bool</code>",id:"xcmexecutionsuspended-bool",level:3}],m={toc:d},c="wrapper";function k(e){var t=e.components,a=(0,i.Z)(e,o);return(0,r.kt)(c,(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The following sections contain Storage methods are part of the default Kusama runtime. On the api, these are exposed via ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.<module>.<method>"),". "),(0,r.kt)("p",null,"(NOTE: These were generated from a static/snapshot view of a recent default Kusama runtime. Some items may not be available in older nodes, or in any customized implementations.)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#assetrate"},"assetRate")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#auctions"},"auctions")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#authoritydiscovery"},"authorityDiscovery")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#authorship"},"authorship")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#babe"},"babe")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#balances"},"balances")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#beefy"},"beefy")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#beefymmrleaf"},"beefyMmrLeaf")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#bounties"},"bounties")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#childbounties"},"childBounties")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#claims"},"claims")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#configuration"},"configuration")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#convictionvoting"},"convictionVoting")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#coretimeassignmentprovider"},"coretimeAssignmentProvider")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#crowdloan"},"crowdloan")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#delegatedstaking"},"delegatedStaking")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#dmp"},"dmp")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#electionprovidermultiphase"},"electionProviderMultiPhase")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#fastunstake"},"fastUnstake")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#fellowshipcollective"},"fellowshipCollective")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#fellowshipreferenda"},"fellowshipReferenda")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#grandpa"},"grandpa")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#historical"},"historical")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#hrmp"},"hrmp")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#indices"},"indices")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#initializer"},"initializer")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#messagequeue"},"messageQueue")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#mmr"},"mmr")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#multisig"},"multisig")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#nis"},"nis")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#niscounterpartbalances"},"nisCounterpartBalances")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#nominationpools"},"nominationPools")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#offences"},"offences")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#ondemandassignmentprovider"},"onDemandAssignmentProvider")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#parainclusion"},"paraInclusion")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#parainherent"},"paraInherent")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#parameters"},"parameters")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#paras"},"paras")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#parascheduler"},"paraScheduler")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#parasdisputes"},"parasDisputes")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#parasessioninfo"},"paraSessionInfo")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#parasshared"},"parasShared")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#parasslashing"},"parasSlashing")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#preimage"},"preimage")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#proxy"},"proxy")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#recovery"},"recovery")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#referenda"},"referenda")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#registrar"},"registrar")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#scheduler"},"scheduler")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#session"},"session")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#slots"},"slots")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#society"},"society")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#staking"},"staking")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#substrate"},"substrate")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#system"},"system")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#timestamp"},"timestamp")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#transactionpayment"},"transactionPayment")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#treasury"},"treasury")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#vesting"},"vesting")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#voterlist"},"voterList")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#whitelist"},"whitelist")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#xcmpallet"},"xcmPallet"))))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"assetrate"},"assetRate"),(0,r.kt)("h3",{id:"conversionratetonativepolkadotruntimecommonimplsversionedlocatableasset-optionu128"},"conversionRateToNative(",(0,r.kt)("inlineCode",{parentName:"h3"},"PolkadotRuntimeCommonImplsVersionedLocatableAsset"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u128>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.assetRate.conversionRateToNative"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Maps an asset to its fixed point representation in the native balance. "),(0,r.kt)("p",{parentName:"li"}," E.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"native_amount = asset_amount * ConversionRateToNative::<T>::get(asset_kind)")," "))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"auctions"},"auctions"),(0,r.kt)("h3",{id:"auctioncounter-u32"},"auctionCounter(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.auctions.auctionCounter")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Number of auctions started so far. ")),(0,r.kt)("h3",{id:"auctioninfo-optionu32u32"},"auctionInfo(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<(u32,u32)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.auctions.auctionInfo"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Information relating to the current auction, if there is one. "),(0,r.kt)("p",{parentName:"li"},' The first item in the tuple is the lease period index that the first of the four  contiguous lease periods on auction is for. The second is the block number when the  auction will "begin to end", i.e. the first block of the Ending Period of the auction. '))),(0,r.kt)("h3",{id:"reservedamountsaccountid32u32-optionu128"},"reservedAmounts(",(0,r.kt)("inlineCode",{parentName:"h3"},"(AccountId32,u32)"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u128>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.auctions.reservedAmounts")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Amounts currently reserved in the accounts of the bidders currently winning  (sub-)ranges. ")),(0,r.kt)("h3",{id:"winningu32-optionoptionaccountid32u32u12836"},"winning(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<[Option<(AccountId32,u32,u128)>;36]>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.auctions.winning")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The winning bids for each of the 10 ranges at each sample in the final Ending Period of  the current auction. The map's key is the 0-based index into the Sample Size. The  first sample of the ending period is 0; the last is ",(0,r.kt)("inlineCode",{parentName:"li"},"Sample Size - 1"),". ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"authoritydiscovery"},"authorityDiscovery"),(0,r.kt)("h3",{id:"keys-vecspauthoritydiscoveryapppublic"},"keys(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<SpAuthorityDiscoveryAppPublic>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.authorityDiscovery.keys")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Keys of the current authority set. ")),(0,r.kt)("h3",{id:"nextkeys-vecspauthoritydiscoveryapppublic"},"nextKeys(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<SpAuthorityDiscoveryAppPublic>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.authorityDiscovery.nextKeys")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Keys of the next authority set. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"authorship"},"authorship"),(0,r.kt)("h3",{id:"author-optionaccountid32"},"author(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<AccountId32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.authorship.author")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Author of current block. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"babe"},"babe"),(0,r.kt)("h3",{id:"authorities-vecspconsensusbabeapppublicu64"},"authorities(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<(SpConsensusBabeAppPublic,u64)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.babe.authorities")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Current epoch authorities. ")),(0,r.kt)("h3",{id:"authorvrfrandomness-optionu832"},"authorVrfRandomness(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<[u8;32]>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.babe.authorVrfRandomness"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    This field should always be populated during block processing unless  secondary plain slots are enabled (which don't contain a VRF output). "),(0,r.kt)("p",{parentName:"li"}," It is set in ",(0,r.kt)("inlineCode",{parentName:"p"},"on_finalize"),", before it will contain the value from the last block. "))),(0,r.kt)("h3",{id:"currentslot-u64"},"currentSlot(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u64")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.babe.currentSlot")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Current slot number. ")),(0,r.kt)("h3",{id:"epochconfig-optionspconsensusbabebabeepochconfiguration"},"epochConfig(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<SpConsensusBabeBabeEpochConfiguration>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.babe.epochConfig")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The configuration for the current epoch. Should never be ",(0,r.kt)("inlineCode",{parentName:"li"},"None")," as it is initialized in  genesis. ")),(0,r.kt)("h3",{id:"epochindex-u64"},"epochIndex(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u64")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.babe.epochIndex")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Current epoch index. ")),(0,r.kt)("h3",{id:"epochstart-u32u32"},"epochStart(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"(u32,u32)")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.babe.epochStart")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The block numbers when the last and current epoch have started, respectively ",(0,r.kt)("inlineCode",{parentName:"li"},"N-1")," and  ",(0,r.kt)("inlineCode",{parentName:"li"},"N"),".  NOTE: We track this is in order to annotate the block number when a given pool of  entropy was fixed (i.e. it was known to chain observers). Since epochs are defined in  slots, which may be skipped, the block numbers may not line up with the slot numbers. ")),(0,r.kt)("h3",{id:"genesisslot-u64"},"genesisSlot(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u64")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.babe.genesisSlot")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The slot at which the first epoch actually started. This is 0  until the first block of the chain. ")),(0,r.kt)("h3",{id:"initialized-optionoptionspconsensusbabedigestspredigest"},"initialized(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<Option<SpConsensusBabeDigestsPreDigest>>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.babe.initialized")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Temporary value (cleared at block finalization) which is ",(0,r.kt)("inlineCode",{parentName:"li"},"Some"),"  if per-block initialization has already been called for current block. ")),(0,r.kt)("h3",{id:"lateness-u32"},"lateness(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.babe.lateness"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    How late the current block is compared to its parent. "),(0,r.kt)("p",{parentName:"li"}," This entry is populated as part of block execution and is cleaned up  on block finalization. Querying this storage entry outside of block  execution context should always yield zero. "))),(0,r.kt)("h3",{id:"nextauthorities-vecspconsensusbabeapppublicu64"},"nextAuthorities(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<(SpConsensusBabeAppPublic,u64)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.babe.nextAuthorities")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Next epoch authorities. ")),(0,r.kt)("h3",{id:"nextepochconfig-optionspconsensusbabebabeepochconfiguration"},"nextEpochConfig(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<SpConsensusBabeBabeEpochConfiguration>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.babe.nextEpochConfig")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The configuration for the next epoch, ",(0,r.kt)("inlineCode",{parentName:"li"},"None")," if the config will not change  (you can fallback to ",(0,r.kt)("inlineCode",{parentName:"li"},"EpochConfig")," instead in that case). ")),(0,r.kt)("h3",{id:"nextrandomness-u832"},"nextRandomness(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"[u8;32]")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.babe.nextRandomness")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Next epoch randomness. ")),(0,r.kt)("h3",{id:"pendingepochconfigchange-optionspconsensusbabedigestsnextconfigdescriptor"},"pendingEpochConfigChange(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<SpConsensusBabeDigestsNextConfigDescriptor>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.babe.pendingEpochConfigChange")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Pending epoch configuration change that will be applied when the next epoch is enacted. ")),(0,r.kt)("h3",{id:"randomness-u832"},"randomness(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"[u8;32]")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.babe.randomness"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The epoch randomness for the ",(0,r.kt)("em",{parentName:"p"},"current")," epoch. "),(0,r.kt)("h4",{parentName:"li",id:"security"},"Security"),(0,r.kt)("p",{parentName:"li"}," This MUST NOT be used for gambling, as it can be influenced by a  malicious validator in the short term. It MAY be used in many  cryptographic protocols, however, so long as one remembers that this  (like everything else on-chain) it is public. For example, it can be  used where a number is needed that cannot have been chosen by an  adversary, for purposes such as public-coin zero-knowledge proofs. "))),(0,r.kt)("h3",{id:"segmentindex-u32"},"segmentIndex(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.babe.segmentIndex"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Randomness under construction. "),(0,r.kt)("p",{parentName:"li"}," We make a trade-off between storage accesses and list length.  We store the under-construction randomness in segments of up to  ",(0,r.kt)("inlineCode",{parentName:"p"},"UNDER_CONSTRUCTION_SEGMENT_LENGTH"),". "),(0,r.kt)("p",{parentName:"li"}," Once a segment reaches this length, we begin the next one.  We reset all segments and return to ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," at the beginning of every  epoch. "))),(0,r.kt)("h3",{id:"skippedepochs-vecu64u32"},"skippedEpochs(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<(u64,u32)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.babe.skippedEpochs"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    A list of the last 100 skipped epochs and the corresponding session index  when the epoch was skipped. "),(0,r.kt)("p",{parentName:"li"}," This is only used for validating equivocation proofs. An equivocation proof  must contains a key-ownership proof for a given session, therefore we need a  way to tie together sessions and epoch indices, i.e. we need to validate that  a validator was the owner of a given key on a given session, and what the  active epoch index was during that session. "))),(0,r.kt)("h3",{id:"underconstructionu32-vecu832"},"underConstruction(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<[u8;32]>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.babe.underConstruction")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    TWOX-NOTE: ",(0,r.kt)("inlineCode",{parentName:"li"},"SegmentIndex")," is an increasing integer, so this is okay. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"balances"},"balances"),(0,r.kt)("h3",{id:"accountaccountid32-palletbalancesaccountdata"},"account(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"PalletBalancesAccountData")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.balances.account"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The Balances pallet example of storing the balance of an account. "),(0,r.kt)("h4",{parentName:"li",id:"example"},"Example"),(0,r.kt)("p",{parentName:"li"}," ",(0,r.kt)("inlineCode",{parentName:"p"},"nocompile  impl pallet_balances::Config for Runtime {  type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>  }  ")," "),(0,r.kt)("p",{parentName:"li"}," You can also store the balance of an account in the ",(0,r.kt)("inlineCode",{parentName:"p"},"System")," pallet. "),(0,r.kt)("h4",{parentName:"li",id:"example-1"},"Example"),(0,r.kt)("p",{parentName:"li"}," ",(0,r.kt)("inlineCode",{parentName:"p"},"nocompile  impl pallet_balances::Config for Runtime {  type AccountStore = System  }  ")," "),(0,r.kt)("p",{parentName:"li"}," But this comes with tradeoffs, storing account balances in the system pallet stores  ",(0,r.kt)("inlineCode",{parentName:"p"},"frame_system")," data alongside the account data contrary to storing account balances in the  ",(0,r.kt)("inlineCode",{parentName:"p"},"Balances")," pallet, which uses a ",(0,r.kt)("inlineCode",{parentName:"p"},"StorageMap")," to store balances data only.  NOTE: This is only used in the case that this pallet is used to store balances. "))),(0,r.kt)("h3",{id:"freezesaccountid32-vecidstagingkusamaruntimeruntimefreezereasonamountu128"},"freezes(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},'Vec<{"id":"StagingKusamaRuntimeRuntimeFreezeReason","amount":"u128"}>')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.balances.freezes")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Freeze locks on account balances. ")),(0,r.kt)("h3",{id:"holdsaccountid32-vecidstagingkusamaruntimeruntimeholdreasonamountu128"},"holds(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},'Vec<{"id":"StagingKusamaRuntimeRuntimeHoldReason","amount":"u128"}>')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.balances.holds")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Holds on account balances. ")),(0,r.kt)("h3",{id:"inactiveissuance-u128"},"inactiveIssuance(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u128")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.balances.inactiveIssuance")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The total units of outstanding deactivated balance in the system. ")),(0,r.kt)("h3",{id:"locksaccountid32-vecpalletbalancesbalancelock"},"locks(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<PalletBalancesBalanceLock>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.balances.locks"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Any liquidity locks on some account balances.  NOTE: Should only be accessed when setting, changing and freeing a lock. "),(0,r.kt)("p",{parentName:"li"}," Use of locks is deprecated in favour of freezes. See ",(0,r.kt)("inlineCode",{parentName:"p"},"https://github.com/paritytech/substrate/pull/12951/")," "))),(0,r.kt)("h3",{id:"reservesaccountid32-vecpalletbalancesreservedata"},"reserves(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<PalletBalancesReserveData>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.balances.reserves"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Named reserves on some account balances. "),(0,r.kt)("p",{parentName:"li"}," Use of reserves is deprecated in favour of holds. See ",(0,r.kt)("inlineCode",{parentName:"p"},"https://github.com/paritytech/substrate/pull/12951/")," "))),(0,r.kt)("h3",{id:"totalissuance-u128"},"totalIssuance(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u128")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.balances.totalIssuance")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The total units issued in the system. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"beefy"},"beefy"),(0,r.kt)("h3",{id:"authorities-vecspconsensusbeefyecdsacryptopublic"},"authorities(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<SpConsensusBeefyEcdsaCryptoPublic>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.beefy.authorities")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The current authorities set ")),(0,r.kt)("h3",{id:"genesisblock-optionu32"},"genesisBlock(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.beefy.genesisBlock")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Block number where BEEFY consensus is enabled/started.  By changing this (through privileged ",(0,r.kt)("inlineCode",{parentName:"li"},"set_new_genesis()"),"), BEEFY consensus is effectively  restarted from the newly set block number. ")),(0,r.kt)("h3",{id:"nextauthorities-vecspconsensusbeefyecdsacryptopublic"},"nextAuthorities(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<SpConsensusBeefyEcdsaCryptoPublic>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.beefy.nextAuthorities")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Authorities set scheduled to be used with the next session ")),(0,r.kt)("h3",{id:"setidsessionu64-optionu32"},"setIdSession(",(0,r.kt)("inlineCode",{parentName:"h3"},"u64"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.beefy.setIdSession"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    A mapping from BEEFY set ID to the index of the ",(0,r.kt)("em",{parentName:"p"},"most recent")," session for which its  members were responsible. "),(0,r.kt)("p",{parentName:"li"}," This is only used for validating equivocation proofs. An equivocation proof must  contains a key-ownership proof for a given session, therefore we need a way to tie  together sessions and BEEFY set ids, i.e. we need to validate that a validator  was the owner of a given key on a given session, and what the active set ID was  during that session. "),(0,r.kt)("p",{parentName:"li"}," TWOX-NOTE: ",(0,r.kt)("inlineCode",{parentName:"p"},"ValidatorSetId")," is not under user control. "))),(0,r.kt)("h3",{id:"validatorsetid-u64"},"validatorSetId(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u64")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.beefy.validatorSetId")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The current validator set id ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"beefymmrleaf"},"beefyMmrLeaf"),(0,r.kt)("h3",{id:"beefyauthorities-spconsensusbeefymmrbeefyauthorityset"},"beefyAuthorities(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"SpConsensusBeefyMmrBeefyAuthoritySet")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.beefyMmrLeaf.beefyAuthorities")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Details of current BEEFY authority set. ")),(0,r.kt)("h3",{id:"beefynextauthorities-spconsensusbeefymmrbeefyauthorityset"},"beefyNextAuthorities(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"SpConsensusBeefyMmrBeefyAuthoritySet")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.beefyMmrLeaf.beefyNextAuthorities"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Details of next BEEFY authority set. "),(0,r.kt)("p",{parentName:"li"}," This storage entry is used as cache for calls to ",(0,r.kt)("inlineCode",{parentName:"p"},"update_beefy_next_authority_set"),". "))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"bounties"},"bounties"),(0,r.kt)("h3",{id:"bountiesu32-optionpalletbountiesbounty"},"bounties(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletBountiesBounty>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.bounties.bounties")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Bounties that have been made. ")),(0,r.kt)("h3",{id:"bountyapprovals-vecu32"},"bountyApprovals(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.bounties.bountyApprovals")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Bounty indices that have been approved but not yet funded. ")),(0,r.kt)("h3",{id:"bountycount-u32"},"bountyCount(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.bounties.bountyCount")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Number of bounty proposals that have been made. ")),(0,r.kt)("h3",{id:"bountydescriptionsu32-optionbytes"},"bountyDescriptions(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<Bytes>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.bounties.bountyDescriptions")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The description of each bounty. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"childbounties"},"childBounties"),(0,r.kt)("h3",{id:"childbountiesu32-u32-optionpalletchildbountieschildbounty"},"childBounties(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32, u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletChildBountiesChildBounty>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.childBounties.childBounties")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Child bounties that have been added. ")),(0,r.kt)("h3",{id:"childbountycount-u32"},"childBountyCount(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.childBounties.childBountyCount")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    DEPRECATED: Replaced with ",(0,r.kt)("inlineCode",{parentName:"li"},"ParentTotalChildBounties")," storage item keeping dedicated counts  for each parent bounty. Number of total child bounties. Will be removed in May 2025. ")),(0,r.kt)("h3",{id:"childbountydescriptionsv1u32-u32-optionbytes"},"childBountyDescriptionsV1(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32, u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<Bytes>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.childBounties.childBountyDescriptionsV1"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The description of each child-bounty. Indexed by ",(0,r.kt)("inlineCode",{parentName:"p"},"(parent_id, child_id)"),". "),(0,r.kt)("p",{parentName:"li"}," This item replaces the ",(0,r.kt)("inlineCode",{parentName:"p"},"ChildBountyDescriptions")," storage item from the V0 storage version. "))),(0,r.kt)("h3",{id:"childrencuratorfeesu32-u128"},"childrenCuratorFees(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u128")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.childBounties.childrenCuratorFees")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The cumulative child-bounty curator fee for each parent bounty. ")),(0,r.kt)("h3",{id:"parentchildbountiesu32-u32"},"parentChildBounties(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.childBounties.parentChildBounties")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Number of active child bounties per parent bounty.  Map of parent bounty index to number of child bounties. ")),(0,r.kt)("h3",{id:"parenttotalchildbountiesu32-u32"},"parentTotalChildBounties(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.childBounties.parentTotalChildBounties")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Number of total child bounties per parent bounty, including completed bounties. ")),(0,r.kt)("h3",{id:"v0tov1childbountyidsu32-optionu32u32"},"v0ToV1ChildBountyIds(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<(u32,u32)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.childBounties.v0ToV1ChildBountyIds"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The mapping of the child bounty ids from storage version ",(0,r.kt)("inlineCode",{parentName:"p"},"V0")," to the new ",(0,r.kt)("inlineCode",{parentName:"p"},"V1")," version. "),(0,r.kt)("p",{parentName:"li"}," The ",(0,r.kt)("inlineCode",{parentName:"p"},"V0")," ids based on total child bounty count ","[",(0,r.kt)("inlineCode",{parentName:"p"},"ChildBountyCount"),"]",(0,r.kt)("inlineCode",{parentName:"p"},". The "),"V1",(0,r.kt)("inlineCode",{parentName:"p"}," version ids  based on the child bounty count per parent bounty ["),"ParentTotalChildBounties`].  The item intended solely for client convenience and not used in the pallet's core logic. "))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"claims"},"claims"),(0,r.kt)("h3",{id:"claimsethereumaddress-optionu128"},"claims(",(0,r.kt)("inlineCode",{parentName:"h3"},"EthereumAddress"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u128>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.claims.claims"))),(0,r.kt)("h3",{id:"preclaimsaccountid32-optionethereumaddress"},"preclaims(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<EthereumAddress>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.claims.preclaims")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Pre-claimed Ethereum accounts, by the Account ID that they are claimed to. ")),(0,r.kt)("h3",{id:"signingethereumaddress-optionpolkadotruntimecommonclaimsstatementkind"},"signing(",(0,r.kt)("inlineCode",{parentName:"h3"},"EthereumAddress"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PolkadotRuntimeCommonClaimsStatementKind>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.claims.signing")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The statement kind that must be signed, if any. ")),(0,r.kt)("h3",{id:"total-u128"},"total(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u128")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.claims.total"))),(0,r.kt)("h3",{id:"vestingethereumaddress-optionu128u128u32"},"vesting(",(0,r.kt)("inlineCode",{parentName:"h3"},"EthereumAddress"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<(u128,u128,u32)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.claims.vesting")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Vesting schedule for a claim.  First balance is the total amount that should be held for vesting.  Second balance is how much should be unlocked per block.  The block number is when the vesting should start. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"configuration"},"configuration"),(0,r.kt)("h3",{id:"activeconfig-polkadotruntimeparachainsconfigurationhostconfiguration"},"activeConfig(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"PolkadotRuntimeParachainsConfigurationHostConfiguration")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.configuration.activeConfig")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The active configuration for the current session. ")),(0,r.kt)("h3",{id:"bypassconsistencycheck-bool"},"bypassConsistencyCheck(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"bool")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.configuration.bypassConsistencyCheck")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    If this is set, then the configuration setters will bypass the consistency checks. This  is meant to be used only as the last resort. ")),(0,r.kt)("h3",{id:"pendingconfigs-vecu32polkadotruntimeparachainsconfigurationhostconfiguration"},"pendingConfigs(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<(u32,PolkadotRuntimeParachainsConfigurationHostConfiguration)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.configuration.pendingConfigs"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Pending configuration changes. "),(0,r.kt)("p",{parentName:"li"}," This is a list of configuration changes, each with a session index at which it should  be applied. "),(0,r.kt)("p",{parentName:"li"}," The list is sorted ascending by session index. Also, this list can only contain at most  2 items: for the next session and for the ",(0,r.kt)("inlineCode",{parentName:"p"},"scheduled_session"),". "))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"convictionvoting"},"convictionVoting"),(0,r.kt)("h3",{id:"classlocksforaccountid32-vecu16u128"},"classLocksFor(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<(u16,u128)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.convictionVoting.classLocksFor")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The voting classes which have a non-zero lock requirement and the lock amounts which they  require. The actual amount locked on behalf of this pallet should always be the maximum of  this list. ")),(0,r.kt)("h3",{id:"votingforaccountid32-u16-palletconvictionvotingvotevoting"},"votingFor(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32, u16"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"PalletConvictionVotingVoteVoting")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.convictionVoting.votingFor")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    All voting for a particular voter in a particular voting class. We store the balance for the  number of votes that we have recorded. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"coretimeassignmentprovider"},"coretimeAssignmentProvider"),(0,r.kt)("h3",{id:"coredescriptorsu32-polkadotruntimeparachainsassignercoretimecoredescriptor"},"coreDescriptors(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"PolkadotRuntimeParachainsAssignerCoretimeCoreDescriptor")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.coretimeAssignmentProvider.coreDescriptors"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Assignments which are currently active. "),(0,r.kt)("p",{parentName:"li"}," They will be picked from ",(0,r.kt)("inlineCode",{parentName:"p"},"PendingAssignments")," once we reach the scheduled block number in  ",(0,r.kt)("inlineCode",{parentName:"p"},"PendingAssignments"),". "))),(0,r.kt)("h3",{id:"coreschedulesu32u32-optionpolkadotruntimeparachainsassignercoretimeschedule"},"coreSchedules(",(0,r.kt)("inlineCode",{parentName:"h3"},"(u32,u32)"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PolkadotRuntimeParachainsAssignerCoretimeSchedule>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.coretimeAssignmentProvider.coreSchedules"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Scheduled assignment sets. "),(0,r.kt)("p",{parentName:"li"}," Assignments as of the given block number. They will go into state once the block number is  reached (and replace whatever was in there before). "))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"crowdloan"},"crowdloan"),(0,r.kt)("h3",{id:"endingscount-u32"},"endingsCount(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.crowdloan.endingsCount")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The number of auctions that have entered into their ending period so far. ")),(0,r.kt)("h3",{id:"fundsu32-optionpolkadotruntimecommoncrowdloanfundinfo"},"funds(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PolkadotRuntimeCommonCrowdloanFundInfo>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.crowdloan.funds")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Info on all of the funds. ")),(0,r.kt)("h3",{id:"newraise-vecu32"},"newRaise(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.crowdloan.newRaise")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The funds that have had additional contributions during the last block. This is used  in order to determine which funds should submit new or updated bids. ")),(0,r.kt)("h3",{id:"nextfundindex-u32"},"nextFundIndex(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.crowdloan.nextFundIndex")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Tracker for the next available fund index ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"delegatedstaking"},"delegatedStaking"),(0,r.kt)("h3",{id:"agentsaccountid32-optionpalletdelegatedstakingagentledger"},"agents(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletDelegatedStakingAgentLedger>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.delegatedStaking.agents")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Map of ",(0,r.kt)("inlineCode",{parentName:"li"},"Agent")," to their ",(0,r.kt)("inlineCode",{parentName:"li"},"Ledger"),". ")),(0,r.kt)("h3",{id:"counterforagents-u32"},"counterForAgents(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.delegatedStaking.counterForAgents")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Counter for the related counted storage map ")),(0,r.kt)("h3",{id:"counterfordelegators-u32"},"counterForDelegators(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.delegatedStaking.counterForDelegators")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Counter for the related counted storage map ")),(0,r.kt)("h3",{id:"delegatorsaccountid32-optionpalletdelegatedstakingdelegation"},"delegators(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletDelegatedStakingDelegation>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.delegatedStaking.delegators"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Map of Delegators to their ",(0,r.kt)("inlineCode",{parentName:"p"},"Delegation"),". "),(0,r.kt)("p",{parentName:"li"}," Implementation note: We are not using a double map with ",(0,r.kt)("inlineCode",{parentName:"p"},"delegator")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"agent")," account  as keys since we want to restrict delegators to delegate only to one account at a time. "))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"dmp"},"dmp"),(0,r.kt)("h3",{id:"deliveryfeefactoru32-u128"},"deliveryFeeFactor(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u128")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.dmp.deliveryFeeFactor")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The factor to multiply the base delivery fee by. ")),(0,r.kt)("h3",{id:"downwardmessagequeueheadsu32-h256"},"downwardMessageQueueHeads(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"H256")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.dmp.downwardMessageQueueHeads"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    A mapping that stores the downward message queue MQC head for each para. "),(0,r.kt)("p",{parentName:"li"}," Each link in this chain has a form:  ",(0,r.kt)("inlineCode",{parentName:"p"},"(prev_head, B, H(M))"),", where "),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"prev_head"),": is the previous head hash or zero if none.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"B"),": is the relay-chain block number in which a message was appended.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"H(M)"),": is the hash of the message being appended."))))),(0,r.kt)("h3",{id:"downwardmessagequeuesu32-vecpolkadotcoreprimitivesinbounddownwardmessage"},"downwardMessageQueues(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<PolkadotCorePrimitivesInboundDownwardMessage>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.dmp.downwardMessageQueues")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The downward messages addressed for a certain para. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"electionprovidermultiphase"},"electionProviderMultiPhase"),(0,r.kt)("h3",{id:"currentphase-palletelectionprovidermultiphasephase"},"currentPhase(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"PalletElectionProviderMultiPhasePhase")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.electionProviderMultiPhase.currentPhase")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Current phase. ")),(0,r.kt)("h3",{id:"desiredtargets-optionu32"},"desiredTargets(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.electionProviderMultiPhase.desiredTargets"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Desired number of targets to elect for this round. "),(0,r.kt)("p",{parentName:"li"}," Only exists when ","[",(0,r.kt)("inlineCode",{parentName:"p"},"Snapshot"),"]"," is present.  Note: This storage type must only be mutated through ","[",(0,r.kt)("inlineCode",{parentName:"p"},"SnapshotWrapper"),"]",". "))),(0,r.kt)("h3",{id:"minimumuntrustedscore-optionspnposelectionselectionscore"},"minimumUntrustedScore(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<SpNposElectionsElectionScore>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.electionProviderMultiPhase.minimumUntrustedScore"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The minimum score that each 'untrusted' solution must attain in order to be considered  feasible. "),(0,r.kt)("p",{parentName:"li"}," Can be set via ",(0,r.kt)("inlineCode",{parentName:"p"},"set_minimum_untrusted_score"),". "))),(0,r.kt)("h3",{id:"queuedsolution-optionpalletelectionprovidermultiphasereadysolution"},"queuedSolution(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletElectionProviderMultiPhaseReadySolution>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.electionProviderMultiPhase.queuedSolution"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Current best solution, signed or unsigned, queued to be returned upon ",(0,r.kt)("inlineCode",{parentName:"p"},"elect"),". "),(0,r.kt)("p",{parentName:"li"}," Always sorted by score. "))),(0,r.kt)("h3",{id:"round-u32"},"round(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.electionProviderMultiPhase.round"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Internal counter for the number of rounds. "),(0,r.kt)("p",{parentName:"li"}," This is useful for de-duplication of transactions submitted to the pool, and general  diagnostics of the pallet. "),(0,r.kt)("p",{parentName:"li"}," This is merely incremented once per every time that an upstream ",(0,r.kt)("inlineCode",{parentName:"p"},"elect")," is called. "))),(0,r.kt)("h3",{id:"signedsubmissionindices-vecspnposelectionselectionscoreu32u32"},"signedSubmissionIndices(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<(SpNposElectionsElectionScore,u32,u32)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.electionProviderMultiPhase.signedSubmissionIndices"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    A sorted, bounded vector of ",(0,r.kt)("inlineCode",{parentName:"p"},"(score, block_number, index)"),", where each ",(0,r.kt)("inlineCode",{parentName:"p"},"index")," points to a  value in ",(0,r.kt)("inlineCode",{parentName:"p"},"SignedSubmissions"),". "),(0,r.kt)("p",{parentName:"li"}," We never need to process more than a single signed submission at a time. Signed submissions  can be quite large, so we're willing to pay the cost of multiple database accesses to access  them one at a time instead of reading and decoding all of them at once. "))),(0,r.kt)("h3",{id:"signedsubmissionnextindex-u32"},"signedSubmissionNextIndex(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.electionProviderMultiPhase.signedSubmissionNextIndex"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The next index to be assigned to an incoming signed submission. "),(0,r.kt)("p",{parentName:"li"}," Every accepted submission is assigned a unique index; that index is bound to that particular  submission for the duration of the election. On election finalization, the next index is  reset to 0. "),(0,r.kt)("p",{parentName:"li"}," We can't just use ",(0,r.kt)("inlineCode",{parentName:"p"},"SignedSubmissionIndices.len()"),", because that's a bounded set; past its  capacity, it will simply saturate. We can't just iterate over ",(0,r.kt)("inlineCode",{parentName:"p"},"SignedSubmissionsMap"),",  because iteration is slow. Instead, we store the value here. "))),(0,r.kt)("h3",{id:"signedsubmissionsmapu32-optionpalletelectionprovidermultiphasesignedsignedsubmission"},"signedSubmissionsMap(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletElectionProviderMultiPhaseSignedSignedSubmission>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.electionProviderMultiPhase.signedSubmissionsMap"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Unchecked, signed solutions. "),(0,r.kt)("p",{parentName:"li"}," Together with ",(0,r.kt)("inlineCode",{parentName:"p"},"SubmissionIndices"),", this stores a bounded set of ",(0,r.kt)("inlineCode",{parentName:"p"},"SignedSubmissions")," while  allowing us to keep only a single one in memory at a time. "),(0,r.kt)("p",{parentName:"li"}," Twox note: the key of the map is an auto-incrementing index which users cannot inspect or  affect; we shouldn't need a cryptographically secure hasher. "))),(0,r.kt)("h3",{id:"snapshot-optionpalletelectionprovidermultiphaseroundsnapshot"},"snapshot(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletElectionProviderMultiPhaseRoundSnapshot>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.electionProviderMultiPhase.snapshot"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Snapshot data of the round. "),(0,r.kt)("p",{parentName:"li"}," This is created at the beginning of the signed phase and cleared upon calling ",(0,r.kt)("inlineCode",{parentName:"p"},"elect"),".  Note: This storage type must only be mutated through ","[",(0,r.kt)("inlineCode",{parentName:"p"},"SnapshotWrapper"),"]",". "))),(0,r.kt)("h3",{id:"snapshotmetadata-optionpalletelectionprovidermultiphasesolutionorsnapshotsize"},"snapshotMetadata(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletElectionProviderMultiPhaseSolutionOrSnapshotSize>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.electionProviderMultiPhase.snapshotMetadata"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The metadata of the ","[",(0,r.kt)("inlineCode",{parentName:"p"},"RoundSnapshot"),"]"," "),(0,r.kt)("p",{parentName:"li"}," Only exists when ","[",(0,r.kt)("inlineCode",{parentName:"p"},"Snapshot"),"]"," is present.  Note: This storage type must only be mutated through ","[",(0,r.kt)("inlineCode",{parentName:"p"},"SnapshotWrapper"),"]",". "))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"fastunstake"},"fastUnstake"),(0,r.kt)("h3",{id:"counterforqueue-u32"},"counterForQueue(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.fastUnstake.counterForQueue")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Counter for the related counted storage map ")),(0,r.kt)("h3",{id:"erastocheckperblock-u32"},"erasToCheckPerBlock(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.fastUnstake.erasToCheckPerBlock"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Number of eras to check per block. "),(0,r.kt)("p",{parentName:"li"}," If set to 0, this pallet does absolutely nothing. Cannot be set to more than  ","[",(0,r.kt)("inlineCode",{parentName:"p"},"Config::MaxErasToCheckPerBlock"),"]",". "),(0,r.kt)("p",{parentName:"li"}," Based on the amount of weight available at ","[",(0,r.kt)("inlineCode",{parentName:"p"},"Pallet::on_idle"),"]",", up to this many eras are  checked. The checking is represented by updating ","[",(0,r.kt)("inlineCode",{parentName:"p"},"UnstakeRequest::checked"),"]",", which is  stored in ","[",(0,r.kt)("inlineCode",{parentName:"p"},"Head"),"]",". "))),(0,r.kt)("h3",{id:"head-optionpalletfastunstakeunstakerequest"},"head(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletFastUnstakeUnstakeRequest>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.fastUnstake.head"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),':    The current "head of the queue" being unstaked. '),(0,r.kt)("p",{parentName:"li"}," The head in itself can be a batch of up to ","[",(0,r.kt)("inlineCode",{parentName:"p"},"Config::BatchSize"),"]"," stakers. "))),(0,r.kt)("h3",{id:"queueaccountid32-optionu128"},"queue(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u128>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.fastUnstake.queue"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The map of all accounts wishing to be unstaked. "),(0,r.kt)("p",{parentName:"li"}," Keeps track of ",(0,r.kt)("inlineCode",{parentName:"p"},"AccountId")," wishing to unstake and it's corresponding deposit. "))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"fellowshipcollective"},"fellowshipCollective"),(0,r.kt)("h3",{id:"idtoindexu16-accountid32-optionu32"},"idToIndex(",(0,r.kt)("inlineCode",{parentName:"h3"},"u16, AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.fellowshipCollective.idToIndex")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The index of each ranks's member into the group of members who have at least that rank. ")),(0,r.kt)("h3",{id:"indextoidu16-u32-optionaccountid32"},"indexToId(",(0,r.kt)("inlineCode",{parentName:"h3"},"u16, u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<AccountId32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.fellowshipCollective.indexToId")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The members in the collective by index. All indices in the range ",(0,r.kt)("inlineCode",{parentName:"li"},"0..MemberCount")," will  return ",(0,r.kt)("inlineCode",{parentName:"li"},"Some"),", however a member's index is not guaranteed to remain unchanged over time. ")),(0,r.kt)("h3",{id:"membercountu16-u32"},"memberCount(",(0,r.kt)("inlineCode",{parentName:"h3"},"u16"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.fellowshipCollective.memberCount")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The number of members in the collective who have at least the rank according to the index  of the vec. ")),(0,r.kt)("h3",{id:"membersaccountid32-optionpalletrankedcollectivememberrecord"},"members(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletRankedCollectiveMemberRecord>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.fellowshipCollective.members")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The current members of the collective. ")),(0,r.kt)("h3",{id:"votingu32-accountid32-optionpalletrankedcollectivevoterecord"},"voting(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32, AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletRankedCollectiveVoteRecord>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.fellowshipCollective.voting")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Votes on a given proposal, if it is ongoing. ")),(0,r.kt)("h3",{id:"votingcleanupu32-optionbytes"},"votingCleanup(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<Bytes>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.fellowshipCollective.votingCleanup"))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"fellowshipreferenda"},"fellowshipReferenda"),(0,r.kt)("h3",{id:"decidingcountu16-u32"},"decidingCount(",(0,r.kt)("inlineCode",{parentName:"h3"},"u16"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.fellowshipReferenda.decidingCount")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The number of referenda being decided currently. ")),(0,r.kt)("h3",{id:"metadataofu32-optionh256"},"metadataOf(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<H256>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.fellowshipReferenda.metadataOf"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The metadata is a general information concerning the referendum.  The ",(0,r.kt)("inlineCode",{parentName:"p"},"Hash")," refers to the preimage of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Preimages")," provider which can be a JSON  dump or IPFS hash of a JSON file. "),(0,r.kt)("p",{parentName:"li"}," Consider a garbage collection for a metadata of finished referendums to ",(0,r.kt)("inlineCode",{parentName:"p"},"unrequest")," (remove)  large preimages. "))),(0,r.kt)("h3",{id:"referendumcount-u32"},"referendumCount(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.fellowshipReferenda.referendumCount")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The next free referendum index, aka the number of referenda started so far. ")),(0,r.kt)("h3",{id:"referenduminfoforu32-optionpalletreferendareferenduminforankedcollectivetally"},"referendumInfoFor(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletReferendaReferendumInfoRankedCollectiveTally>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.fellowshipReferenda.referendumInfoFor")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Information concerning any given referendum. ")),(0,r.kt)("h3",{id:"trackqueueu16-vecu32u32"},"trackQueue(",(0,r.kt)("inlineCode",{parentName:"h3"},"u16"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<(u32,u32)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.fellowshipReferenda.trackQueue"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The sorted list of referenda ready to be decided but not yet being decided, ordered by  conviction-weighted approvals. "),(0,r.kt)("p",{parentName:"li"}," This should be empty if ",(0,r.kt)("inlineCode",{parentName:"p"},"DecidingCount")," is less than ",(0,r.kt)("inlineCode",{parentName:"p"},"TrackInfo::max_deciding"),". "))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"grandpa"},"grandpa"),(0,r.kt)("h3",{id:"authorities-vecspconsensusgrandpaapppublicu64"},"authorities(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<(SpConsensusGrandpaAppPublic,u64)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.grandpa.authorities")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The current list of authorities. ")),(0,r.kt)("h3",{id:"currentsetid-u64"},"currentSetId(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u64")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.grandpa.currentSetId")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),':    The number of changes (both in terms of keys and underlying economic responsibilities)  in the "set" of Grandpa validators from genesis. ')),(0,r.kt)("h3",{id:"nextforced-optionu32"},"nextForced(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.grandpa.nextForced")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    next block number where we can force a change. ")),(0,r.kt)("h3",{id:"pendingchange-optionpalletgrandpastoredpendingchange"},"pendingChange(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletGrandpaStoredPendingChange>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.grandpa.pendingChange")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Pending change: (signaled at, scheduled change). ")),(0,r.kt)("h3",{id:"setidsessionu64-optionu32-1"},"setIdSession(",(0,r.kt)("inlineCode",{parentName:"h3"},"u64"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.grandpa.setIdSession"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    A mapping from grandpa set ID to the index of the ",(0,r.kt)("em",{parentName:"p"},"most recent")," session for which its  members were responsible. "),(0,r.kt)("p",{parentName:"li"}," This is only used for validating equivocation proofs. An equivocation proof must  contains a key-ownership proof for a given session, therefore we need a way to tie  together sessions and GRANDPA set ids, i.e. we need to validate that a validator  was the owner of a given key on a given session, and what the active set ID was  during that session. "),(0,r.kt)("p",{parentName:"li"}," TWOX-NOTE: ",(0,r.kt)("inlineCode",{parentName:"p"},"SetId")," is not under user control. "))),(0,r.kt)("h3",{id:"stalled-optionu32u32"},"stalled(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<(u32,u32)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.grandpa.stalled")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," if we are currently stalled. ")),(0,r.kt)("h3",{id:"state-palletgrandpastoredstate"},"state(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"PalletGrandpaStoredState")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.grandpa.state")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    State of the current authority set. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"historical"},"historical"),(0,r.kt)("h3",{id:"historicalsessionsu32-optionh256u32"},"historicalSessions(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<(H256,u32)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.historical.historicalSessions")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Mapping from historical session indices to session-data root hash and validator count. ")),(0,r.kt)("h3",{id:"storedrange-optionu32u32"},"storedRange(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<(u32,u32)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.historical.storedRange")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The range of historical sessions we store. [first, last) ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"hrmp"},"hrmp"),(0,r.kt)("h3",{id:"hrmpacceptedchannelrequestcountu32-u32"},"hrmpAcceptedChannelRequestCount(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.hrmp.hrmpAcceptedChannelRequestCount")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    This mapping tracks how many open channel requests were accepted by a given recipient para.  Invariant: ",(0,r.kt)("inlineCode",{parentName:"li"},"HrmpOpenChannelRequests")," should contain the same number of items ",(0,r.kt)("inlineCode",{parentName:"li"},"(_, X)")," with  ",(0,r.kt)("inlineCode",{parentName:"li"},"confirmed")," set to true, as the number of ",(0,r.kt)("inlineCode",{parentName:"li"},"HrmpAcceptedChannelRequestCount")," for ",(0,r.kt)("inlineCode",{parentName:"li"},"X"),". ")),(0,r.kt)("h3",{id:"hrmpchannelcontentspolkadotparachainprimitivesprimitiveshrmpchannelid-vecpolkadotcoreprimitivesinboundhrmpmessage"},"hrmpChannelContents(",(0,r.kt)("inlineCode",{parentName:"h3"},"PolkadotParachainPrimitivesPrimitivesHrmpChannelId"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<PolkadotCorePrimitivesInboundHrmpMessage>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.hrmp.hrmpChannelContents")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Storage for the messages for each channel.  Invariant: cannot be non-empty if the corresponding channel in ",(0,r.kt)("inlineCode",{parentName:"li"},"HrmpChannels")," is ",(0,r.kt)("inlineCode",{parentName:"li"},"None"),". ")),(0,r.kt)("h3",{id:"hrmpchanneldigestsu32-vecu32vecu32"},"hrmpChannelDigests(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<(u32,Vec<u32>)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.hrmp.hrmpChannelDigests"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Maintains a mapping that can be used to answer the question: What paras sent a message at  the given block number for a given receiver. Invariants: "),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The inner ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec<ParaId>")," is never empty.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The inner ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec<ParaId>")," cannot store two same ",(0,r.kt)("inlineCode",{parentName:"p"},"ParaId"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The outer vector is sorted ascending by block number and cannot store two items with the same block number. "))))),(0,r.kt)("h3",{id:"hrmpchannelspolkadotparachainprimitivesprimitiveshrmpchannelid-optionpolkadotruntimeparachainshrmphrmpchannel"},"hrmpChannels(",(0,r.kt)("inlineCode",{parentName:"h3"},"PolkadotParachainPrimitivesPrimitivesHrmpChannelId"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PolkadotRuntimeParachainsHrmpHrmpChannel>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.hrmp.hrmpChannels"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    HRMP channel data associated with each para.  Invariant: "),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"each participant in the channel should satisfy ",(0,r.kt)("inlineCode",{parentName:"li"},"Paras::is_valid_para(P)")," within a session.")))),(0,r.kt)("h3",{id:"hrmpclosechannelrequestspolkadotparachainprimitivesprimitiveshrmpchannelid-optionnull"},"hrmpCloseChannelRequests(",(0,r.kt)("inlineCode",{parentName:"h3"},"PolkadotParachainPrimitivesPrimitivesHrmpChannelId"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<Null>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.hrmp.hrmpCloseChannelRequests"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    A set of pending HRMP close channel requests that are going to be closed during the session  change. Used for checking if a given channel is registered for closure. "),(0,r.kt)("p",{parentName:"li"}," The set is accompanied by a list for iteration. "),(0,r.kt)("p",{parentName:"li"}," Invariant: "),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"There are no channels that exists in list but not in the set and vice versa.")))),(0,r.kt)("h3",{id:"hrmpclosechannelrequestslist-vecpolkadotparachainprimitivesprimitiveshrmpchannelid"},"hrmpCloseChannelRequestsList(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<PolkadotParachainPrimitivesPrimitivesHrmpChannelId>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.hrmp.hrmpCloseChannelRequestsList"))),(0,r.kt)("h3",{id:"hrmpegresschannelsindexu32-vecu32"},"hrmpEgressChannelsIndex(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.hrmp.hrmpEgressChannelsIndex"))),(0,r.kt)("h3",{id:"hrmpingresschannelsindexu32-vecu32"},"hrmpIngressChannelsIndex(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.hrmp.hrmpIngressChannelsIndex"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Ingress/egress indexes allow to find all the senders and receivers given the opposite side.  I.e. "),(0,r.kt)("p",{parentName:"li"}," (a) ingress index allows to find all the senders for a given recipient.  (b) egress index allows to find all the recipients for a given sender. "),(0,r.kt)("p",{parentName:"li"}," Invariants: "),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"for each ingress index entry for ",(0,r.kt)("inlineCode",{parentName:"p"},"P")," each item ",(0,r.kt)("inlineCode",{parentName:"p"},"I")," in the index should present in ",(0,r.kt)("inlineCode",{parentName:"p"},"HrmpChannels")," as ",(0,r.kt)("inlineCode",{parentName:"p"},"(I, P)"),". ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"for each egress index entry for ",(0,r.kt)("inlineCode",{parentName:"p"},"P")," each item ",(0,r.kt)("inlineCode",{parentName:"p"},"E")," in the index should present in ",(0,r.kt)("inlineCode",{parentName:"p"},"HrmpChannels")," as ",(0,r.kt)("inlineCode",{parentName:"p"},"(P, E)"),". ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"there should be no other dangling channels in ",(0,r.kt)("inlineCode",{parentName:"p"},"HrmpChannels"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"the vectors are sorted."))))),(0,r.kt)("h3",{id:"hrmpopenchannelrequestcountu32-u32"},"hrmpOpenChannelRequestCount(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.hrmp.hrmpOpenChannelRequestCount")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    This mapping tracks how many open channel requests are initiated by a given sender para.  Invariant: ",(0,r.kt)("inlineCode",{parentName:"li"},"HrmpOpenChannelRequests")," should contain the same number of items that has  ",(0,r.kt)("inlineCode",{parentName:"li"},"(X, _)")," as the number of ",(0,r.kt)("inlineCode",{parentName:"li"},"HrmpOpenChannelRequestCount")," for ",(0,r.kt)("inlineCode",{parentName:"li"},"X"),". ")),(0,r.kt)("h3",{id:"hrmpopenchannelrequestspolkadotparachainprimitivesprimitiveshrmpchannelid-optionpolkadotruntimeparachainshrmphrmpopenchannelrequest"},"hrmpOpenChannelRequests(",(0,r.kt)("inlineCode",{parentName:"h3"},"PolkadotParachainPrimitivesPrimitivesHrmpChannelId"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PolkadotRuntimeParachainsHrmpHrmpOpenChannelRequest>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.hrmp.hrmpOpenChannelRequests"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The set of pending HRMP open channel requests. "),(0,r.kt)("p",{parentName:"li"}," The set is accompanied by a list for iteration. "),(0,r.kt)("p",{parentName:"li"}," Invariant: "),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"There are no channels that exists in list but not in the set and vice versa.")))),(0,r.kt)("h3",{id:"hrmpopenchannelrequestslist-vecpolkadotparachainprimitivesprimitiveshrmpchannelid"},"hrmpOpenChannelRequestsList(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<PolkadotParachainPrimitivesPrimitivesHrmpChannelId>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.hrmp.hrmpOpenChannelRequestsList"))),(0,r.kt)("h3",{id:"hrmpwatermarksu32-optionu32"},"hrmpWatermarks(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.hrmp.hrmpWatermarks"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The HRMP watermark associated with each para.  Invariant: "),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"each para ",(0,r.kt)("inlineCode",{parentName:"li"},"P")," used here as a key should satisfy ",(0,r.kt)("inlineCode",{parentName:"li"},"Paras::is_valid_para(P)")," within a session. ")))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"indices"},"indices"),(0,r.kt)("h3",{id:"accountsu32-optionaccountid32u128bool"},"accounts(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<(AccountId32,u128,bool)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.indices.accounts")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The lookup from index to account. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"initializer"},"initializer"),(0,r.kt)("h3",{id:"bufferedsessionchanges-vecpolkadotruntimeparachainsinitializerbufferedsessionchange"},"bufferedSessionChanges(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<PolkadotRuntimeParachainsInitializerBufferedSessionChange>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.initializer.bufferedSessionChanges"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Buffered session changes. "),(0,r.kt)("p",{parentName:"li"}," Typically this will be empty or one element long. Apart from that this item never hits  the storage. "),(0,r.kt)("p",{parentName:"li"}," However this is a ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec")," regardless to handle various edge cases that may occur at runtime  upgrade boundaries or if governance intervenes. "))),(0,r.kt)("h3",{id:"hasinitialized-optionnull"},"hasInitialized(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<Null>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.initializer.hasInitialized"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Whether the parachains modules have been initialized within this block. "),(0,r.kt)("p",{parentName:"li"}," Semantically a ",(0,r.kt)("inlineCode",{parentName:"p"},"bool"),", but this guarantees it should never hit the trie,  as this is cleared in ",(0,r.kt)("inlineCode",{parentName:"p"},"on_finalize")," and Frame optimizes ",(0,r.kt)("inlineCode",{parentName:"p"},"None")," values to be empty values. "),(0,r.kt)("p",{parentName:"li"}," As a ",(0,r.kt)("inlineCode",{parentName:"p"},"bool"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"set(false)")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"remove()")," both lead to the next ",(0,r.kt)("inlineCode",{parentName:"p"},"get()")," being false, but one  of them writes to the trie and one does not. This confusion makes ",(0,r.kt)("inlineCode",{parentName:"p"},"Option<()>")," more suitable  for the semantics of this variable. "))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"messagequeue"},"messageQueue"),(0,r.kt)("h3",{id:"bookstateforpolkadotruntimeparachainsinclusionaggregatemessageorigin-palletmessagequeuebookstate"},"bookStateFor(",(0,r.kt)("inlineCode",{parentName:"h3"},"PolkadotRuntimeParachainsInclusionAggregateMessageOrigin"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"PalletMessageQueueBookState")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.messageQueue.bookStateFor")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The index of the first and last (non-empty) pages. ")),(0,r.kt)("h3",{id:"pagespolkadotruntimeparachainsinclusionaggregatemessageorigin-u32-optionpalletmessagequeuepage"},"pages(",(0,r.kt)("inlineCode",{parentName:"h3"},"PolkadotRuntimeParachainsInclusionAggregateMessageOrigin, u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletMessageQueuePage>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.messageQueue.pages")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The map of page indices to pages. ")),(0,r.kt)("h3",{id:"servicehead-optionpolkadotruntimeparachainsinclusionaggregatemessageorigin"},"serviceHead(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PolkadotRuntimeParachainsInclusionAggregateMessageOrigin>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.messageQueue.serviceHead")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The origin at which we should begin servicing. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"mmr"},"mmr"),(0,r.kt)("h3",{id:"nodesu64-optionh256"},"nodes(",(0,r.kt)("inlineCode",{parentName:"h3"},"u64"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<H256>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.mmr.nodes"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Hashes of the nodes in the MMR. "),(0,r.kt)("p",{parentName:"li"}," Note this collection only contains MMR peaks, the inner nodes (and leaves)  are pruned and only stored in the Offchain DB. "))),(0,r.kt)("h3",{id:"numberofleaves-u64"},"numberOfLeaves(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u64")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.mmr.numberOfLeaves")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Current size of the MMR (number of leaves). ")),(0,r.kt)("h3",{id:"roothash-h256"},"rootHash(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"H256")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.mmr.rootHash")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Latest MMR Root hash. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"multisig"},"multisig"),(0,r.kt)("h3",{id:"multisigsaccountid32-u832-optionpalletmultisigmultisig"},"multisigs(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32, [u8;32]"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletMultisigMultisig>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.multisig.multisigs")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The set of open multisig operations. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"nis"},"nis"),(0,r.kt)("h3",{id:"queuesu32-vecpalletnisbid"},"queues(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<PalletNisBid>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nis.queues")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The queues of bids. Indexed by duration (in ",(0,r.kt)("inlineCode",{parentName:"li"},"Period"),"s). ")),(0,r.kt)("h3",{id:"queuetotals-vecu32u128"},"queueTotals(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<(u32,u128)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.nis.queueTotals"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The totals of items and balances within each queue. Saves a lot of storage reads in the  case of sparsely packed queues. "),(0,r.kt)("p",{parentName:"li"}," The vector is indexed by duration in ",(0,r.kt)("inlineCode",{parentName:"p"},"Period"),"s, offset by one, so information on the queue  whose duration is one ",(0,r.kt)("inlineCode",{parentName:"p"},"Period")," would be storage ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),". "))),(0,r.kt)("h3",{id:"receiptsu32-optionpalletnisreceiptrecord"},"receipts(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletNisReceiptRecord>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nis.receipts")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The currently outstanding receipts, indexed according to the order of creation. ")),(0,r.kt)("h3",{id:"summary-palletnissummaryrecord"},"summary(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"PalletNisSummaryRecord")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nis.summary")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Summary information over the general state. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"niscounterpartbalances"},"nisCounterpartBalances"),(0,r.kt)("h3",{id:"accountaccountid32-palletbalancesaccountdata-1"},"account(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"PalletBalancesAccountData")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.nisCounterpartBalances.account"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The Balances pallet example of storing the balance of an account. "),(0,r.kt)("h4",{parentName:"li",id:"example-2"},"Example"),(0,r.kt)("p",{parentName:"li"}," ",(0,r.kt)("inlineCode",{parentName:"p"},"nocompile  impl pallet_balances::Config for Runtime {  type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>  }  ")," "),(0,r.kt)("p",{parentName:"li"}," You can also store the balance of an account in the ",(0,r.kt)("inlineCode",{parentName:"p"},"System")," pallet. "),(0,r.kt)("h4",{parentName:"li",id:"example-3"},"Example"),(0,r.kt)("p",{parentName:"li"}," ",(0,r.kt)("inlineCode",{parentName:"p"},"nocompile  impl pallet_balances::Config for Runtime {  type AccountStore = System  }  ")," "),(0,r.kt)("p",{parentName:"li"}," But this comes with tradeoffs, storing account balances in the system pallet stores  ",(0,r.kt)("inlineCode",{parentName:"p"},"frame_system")," data alongside the account data contrary to storing account balances in the  ",(0,r.kt)("inlineCode",{parentName:"p"},"Balances")," pallet, which uses a ",(0,r.kt)("inlineCode",{parentName:"p"},"StorageMap")," to store balances data only.  NOTE: This is only used in the case that this pallet is used to store balances. "))),(0,r.kt)("h3",{id:"freezesaccountid32-vecframesupporttokensmiscidamount"},"freezes(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<FrameSupportTokensMiscIdAmount>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nisCounterpartBalances.freezes")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Freeze locks on account balances. ")),(0,r.kt)("h3",{id:"holdsaccountid32-vecidstagingkusamaruntimeruntimeholdreasonamountu128-1"},"holds(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},'Vec<{"id":"StagingKusamaRuntimeRuntimeHoldReason","amount":"u128"}>')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nisCounterpartBalances.holds")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Holds on account balances. ")),(0,r.kt)("h3",{id:"inactiveissuance-u128-1"},"inactiveIssuance(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u128")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nisCounterpartBalances.inactiveIssuance")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The total units of outstanding deactivated balance in the system. ")),(0,r.kt)("h3",{id:"locksaccountid32-vecpalletbalancesbalancelock-1"},"locks(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<PalletBalancesBalanceLock>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.nisCounterpartBalances.locks"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Any liquidity locks on some account balances.  NOTE: Should only be accessed when setting, changing and freeing a lock. "),(0,r.kt)("p",{parentName:"li"}," Use of locks is deprecated in favour of freezes. See ",(0,r.kt)("inlineCode",{parentName:"p"},"https://github.com/paritytech/substrate/pull/12951/")," "))),(0,r.kt)("h3",{id:"reservesaccountid32-vecpalletbalancesreservedata-1"},"reserves(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<PalletBalancesReserveData>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.nisCounterpartBalances.reserves"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Named reserves on some account balances. "),(0,r.kt)("p",{parentName:"li"}," Use of reserves is deprecated in favour of holds. See ",(0,r.kt)("inlineCode",{parentName:"p"},"https://github.com/paritytech/substrate/pull/12951/")," "))),(0,r.kt)("h3",{id:"totalissuance-u128-1"},"totalIssuance(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u128")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nisCounterpartBalances.totalIssuance")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The total units issued in the system. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"nominationpools"},"nominationPools"),(0,r.kt)("h3",{id:"bondedpoolsu32-optionpalletnominationpoolsbondedpoolinner"},"bondedPools(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletNominationPoolsBondedPoolInner>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nominationPools.bondedPools")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Storage for bonded pools. ")),(0,r.kt)("h3",{id:"claimpermissionsaccountid32-palletnominationpoolsclaimpermission"},"claimPermissions(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"PalletNominationPoolsClaimPermission")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nominationPools.claimPermissions")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Map from a pool member account to their opted claim permission. ")),(0,r.kt)("h3",{id:"counterforbondedpools-u32"},"counterForBondedPools(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nominationPools.counterForBondedPools")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Counter for the related counted storage map ")),(0,r.kt)("h3",{id:"counterformetadata-u32"},"counterForMetadata(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nominationPools.counterForMetadata")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Counter for the related counted storage map ")),(0,r.kt)("h3",{id:"counterforpoolmembers-u32"},"counterForPoolMembers(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nominationPools.counterForPoolMembers")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Counter for the related counted storage map ")),(0,r.kt)("h3",{id:"counterforreversepoolidlookup-u32"},"counterForReversePoolIdLookup(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nominationPools.counterForReversePoolIdLookup")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Counter for the related counted storage map ")),(0,r.kt)("h3",{id:"counterforrewardpools-u32"},"counterForRewardPools(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nominationPools.counterForRewardPools")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Counter for the related counted storage map ")),(0,r.kt)("h3",{id:"counterforsubpoolsstorage-u32"},"counterForSubPoolsStorage(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nominationPools.counterForSubPoolsStorage")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Counter for the related counted storage map ")),(0,r.kt)("h3",{id:"globalmaxcommission-optionperbill"},"globalMaxCommission(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<Perbill>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nominationPools.globalMaxCommission")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The maximum commission that can be charged by a pool. Used on commission payouts to bound  pool commissions that are > ",(0,r.kt)("inlineCode",{parentName:"li"},"GlobalMaxCommission"),", necessary if a future  ",(0,r.kt)("inlineCode",{parentName:"li"},"GlobalMaxCommission")," is lower than some current pool commissions. ")),(0,r.kt)("h3",{id:"lastpoolid-u32"},"lastPoolId(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nominationPools.lastPoolId")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Ever increasing number of all pools created so far. ")),(0,r.kt)("h3",{id:"maxpoolmembers-optionu32"},"maxPoolMembers(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nominationPools.maxPoolMembers")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Maximum number of members that can exist in the system. If ",(0,r.kt)("inlineCode",{parentName:"li"},"None"),", then the count  members are not bound on a system wide basis. ")),(0,r.kt)("h3",{id:"maxpoolmembersperpool-optionu32"},"maxPoolMembersPerPool(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nominationPools.maxPoolMembersPerPool")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Maximum number of members that may belong to pool. If ",(0,r.kt)("inlineCode",{parentName:"li"},"None"),", then the count of  members is not bound on a per pool basis. ")),(0,r.kt)("h3",{id:"maxpools-optionu32"},"maxPools(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nominationPools.maxPools")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Maximum number of nomination pools that can exist. If ",(0,r.kt)("inlineCode",{parentName:"li"},"None"),", then an unbounded number of  pools can exist. ")),(0,r.kt)("h3",{id:"metadatau32-bytes"},"metadata(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Bytes")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nominationPools.metadata")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Metadata for the pool. ")),(0,r.kt)("h3",{id:"mincreatebond-u128"},"minCreateBond(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u128")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.nominationPools.minCreateBond"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Minimum bond required to create a pool. "),(0,r.kt)("p",{parentName:"li"},' This is the amount that the depositor must put as their initial stake in the pool, as an  indication of "skin in the game". '),(0,r.kt)("p",{parentName:"li"}," This is the value that will always exist in the staking ledger of the pool bonded account  while all other accounts leave. "))),(0,r.kt)("h3",{id:"minjoinbond-u128"},"minJoinBond(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u128")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nominationPools.minJoinBond")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Minimum amount to bond to join a pool. ")),(0,r.kt)("h3",{id:"poolmembersaccountid32-optionpalletnominationpoolspoolmember"},"poolMembers(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletNominationPoolsPoolMember>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.nominationPools.poolMembers"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Active members. "),(0,r.kt)("p",{parentName:"li"}," TWOX-NOTE: SAFE since ",(0,r.kt)("inlineCode",{parentName:"p"},"AccountId")," is a secure hash. "))),(0,r.kt)("h3",{id:"reversepoolidlookupaccountid32-optionu32"},"reversePoolIdLookup(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.nominationPools.reversePoolIdLookup"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    A reverse lookup from the pool's account id to its id. "),(0,r.kt)("p",{parentName:"li"}," This is only used for slashing and on automatic withdraw update. In all other instances, the  pool id is used, and the accounts are deterministically derived from it. "))),(0,r.kt)("h3",{id:"rewardpoolsu32-optionpalletnominationpoolsrewardpool"},"rewardPools(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletNominationPoolsRewardPool>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nominationPools.rewardPools")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Reward pools. This is where there rewards for each pool accumulate. When a members payout is  claimed, the balance comes out of the reward pool. Keyed by the bonded pools account. ")),(0,r.kt)("h3",{id:"subpoolsstorageu32-optionpalletnominationpoolssubpools"},"subPoolsStorage(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletNominationPoolsSubPools>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.nominationPools.subPoolsStorage")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Groups of unbonding pools. Each group of unbonding pools belongs to a  bonded pool, hence the name sub-pools. Keyed by the bonded pools account. ")),(0,r.kt)("h3",{id:"totalvaluelocked-u128"},"totalValueLocked(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u128")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.nominationPools.totalValueLocked"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The sum of funds across all pools. "),(0,r.kt)("p",{parentName:"li"}," This might be lower but never higher than the sum of ",(0,r.kt)("inlineCode",{parentName:"p"},"total_balance")," of all ","[",(0,r.kt)("inlineCode",{parentName:"p"},"PoolMembers"),"]","  because calling ",(0,r.kt)("inlineCode",{parentName:"p"},"pool_withdraw_unbonded")," might decrease the total stake of the pool's  ",(0,r.kt)("inlineCode",{parentName:"p"},"bonded_account")," without adjusting the pallet-internal ",(0,r.kt)("inlineCode",{parentName:"p"},"UnbondingPool"),"'s. "))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"offences"},"offences"),(0,r.kt)("h3",{id:"concurrentreportsindexu816-bytes-vech256"},"concurrentReportsIndex(",(0,r.kt)("inlineCode",{parentName:"h3"},"[u8;16], Bytes"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<H256>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.offences.concurrentReportsIndex")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    A vector of reports of the same kind that happened at the same time slot. ")),(0,r.kt)("h3",{id:"reportsh256-optionspstakingoffenceoffencedetails"},"reports(",(0,r.kt)("inlineCode",{parentName:"h3"},"H256"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<SpStakingOffenceOffenceDetails>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.offences.reports")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The primary structure that holds all offence records keyed by report identifiers. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"ondemandassignmentprovider"},"onDemandAssignmentProvider"),(0,r.kt)("h3",{id:"affinityentriesu32-binaryheapenqueuedorder"},"affinityEntries(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"BinaryHeapEnqueuedOrder")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.onDemandAssignmentProvider.affinityEntries")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Queue entries that are currently bound to a particular core due to core affinity. ")),(0,r.kt)("h3",{id:"creditsaccountid32-u128"},"credits(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u128")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.onDemandAssignmentProvider.credits")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Keeps track of credits owned by each account. ")),(0,r.kt)("h3",{id:"freeentries-binaryheapenqueuedorder"},"freeEntries(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"BinaryHeapEnqueuedOrder")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.onDemandAssignmentProvider.freeEntries")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Priority queue for all orders which don't yet (or not any more) have any core affinity. ")),(0,r.kt)("h3",{id:"paraidaffinityu32-optionpolkadotruntimeparachainsondemandtypescoreaffinitycount"},"paraIdAffinity(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PolkadotRuntimeParachainsOnDemandTypesCoreAffinityCount>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.onDemandAssignmentProvider.paraIdAffinity")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Maps a ",(0,r.kt)("inlineCode",{parentName:"li"},"ParaId")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"CoreIndex")," and keeps track of how many assignments the scheduler has in  it's lookahead. Keeping track of this affinity prevents parallel execution of the same  ",(0,r.kt)("inlineCode",{parentName:"li"},"ParaId")," on two or more ",(0,r.kt)("inlineCode",{parentName:"li"},"CoreIndex"),"es. ")),(0,r.kt)("h3",{id:"queuestatus-polkadotruntimeparachainsondemandtypesqueuestatustype"},"queueStatus(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"PolkadotRuntimeParachainsOnDemandTypesQueueStatusType")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.onDemandAssignmentProvider.queueStatus")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Overall status of queue (both free + affinity entries) ")),(0,r.kt)("h3",{id:"revenue-vecu128"},"revenue(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<u128>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.onDemandAssignmentProvider.revenue")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Keeps track of accumulated revenue from on demand order sales. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"parainclusion"},"paraInclusion"),(0,r.kt)("h3",{id:"v1u32-optionvecpolkadotruntimeparachainsinclusioncandidatependingavailability"},"v1(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<Vec<PolkadotRuntimeParachainsInclusionCandidatePendingAvailability>>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.paraInclusion.v1")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Candidates pending availability by ",(0,r.kt)("inlineCode",{parentName:"li"},"ParaId"),". They form a chain starting from the latest  included head of the para.  Use a different prefix post-migration to v1, since the v0 ",(0,r.kt)("inlineCode",{parentName:"li"},"PendingAvailability")," storage  would otherwise have the exact same prefix which could cause undefined behaviour when doing  the migration. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"parainherent"},"paraInherent"),(0,r.kt)("h3",{id:"included-optionnull"},"included(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<Null>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.paraInherent.included"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Whether the paras inherent was included within this block. "),(0,r.kt)("p",{parentName:"li"}," The ",(0,r.kt)("inlineCode",{parentName:"p"},"Option<()>")," is effectively a ",(0,r.kt)("inlineCode",{parentName:"p"},"bool"),", but it never hits storage in the ",(0,r.kt)("inlineCode",{parentName:"p"},"None")," variant  due to the guarantees of FRAME's storage APIs. "),(0,r.kt)("p",{parentName:"li"}," If this is ",(0,r.kt)("inlineCode",{parentName:"p"},"None")," at the end of the block, we panic and render the block invalid. "))),(0,r.kt)("h3",{id:"onchainvotes-optionpolkadotprimitivesvstagingscrapedonchainvotes"},"onChainVotes(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PolkadotPrimitivesVstagingScrapedOnChainVotes>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.paraInherent.onChainVotes")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Scraped on chain data for extracting resolved disputes as well as backing votes. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"parameters"},"parameters"),(0,r.kt)("h3",{id:"parametersstagingkusamaruntimeruntimeparameterskey-optionstagingkusamaruntimeruntimeparametersvalue"},"parameters(",(0,r.kt)("inlineCode",{parentName:"h3"},"StagingKusamaRuntimeRuntimeParametersKey"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<StagingKusamaRuntimeRuntimeParametersValue>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.parameters.parameters")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Stored parameters. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"paras"},"paras"),(0,r.kt)("h3",{id:"actionsqueueu32-vecu32"},"actionsQueue(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.paras.actionsQueue")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The actions to perform during the start of a specific session index. ")),(0,r.kt)("h3",{id:"codebyhashh256-optionbytes"},"codeByHash(",(0,r.kt)("inlineCode",{parentName:"h3"},"H256"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<Bytes>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.paras.codeByHash"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Validation code stored by its hash. "),(0,r.kt)("p",{parentName:"li"}," This storage is consistent with ","[",(0,r.kt)("inlineCode",{parentName:"p"},"FutureCodeHash"),"]",", ","[",(0,r.kt)("inlineCode",{parentName:"p"},"CurrentCodeHash"),"]"," and  ","[",(0,r.kt)("inlineCode",{parentName:"p"},"PastCodeHash"),"]",". "))),(0,r.kt)("h3",{id:"codebyhashrefsh256-u32"},"codeByHashRefs(",(0,r.kt)("inlineCode",{parentName:"h3"},"H256"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.paras.codeByHashRefs")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The number of reference on the validation code in ","[",(0,r.kt)("inlineCode",{parentName:"li"},"CodeByHash"),"]"," storage. ")),(0,r.kt)("h3",{id:"currentcodehashu32-optionh256"},"currentCodeHash(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<H256>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.paras.currentCodeHash"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The validation code hash of every live para. "),(0,r.kt)("p",{parentName:"li"}," Corresponding code can be retrieved with ","[",(0,r.kt)("inlineCode",{parentName:"p"},"CodeByHash"),"]",". "))),(0,r.kt)("h3",{id:"futurecodehashu32-optionh256"},"futureCodeHash(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<H256>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.paras.futureCodeHash"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The actual future code hash of a para. "),(0,r.kt)("p",{parentName:"li"}," Corresponding code can be retrieved with ","[",(0,r.kt)("inlineCode",{parentName:"p"},"CodeByHash"),"]",". "))),(0,r.kt)("h3",{id:"futurecodeupgradesu32-optionu32"},"futureCodeUpgrades(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.paras.futureCodeUpgrades"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The block number at which the planned code change is expected for a parachain. "),(0,r.kt)("p",{parentName:"li"}," The change will be applied after the first parablock for this ID included which executes  in the context of a relay chain block with a number >= ",(0,r.kt)("inlineCode",{parentName:"p"},"expected_at"),". "))),(0,r.kt)("h3",{id:"futurecodeupgradesat-vecu32u32"},"futureCodeUpgradesAt(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<(u32,u32)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.paras.futureCodeUpgradesAt"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The list of upcoming future code upgrades. "),(0,r.kt)("p",{parentName:"li"}," Each item is a pair of the parachain and the expected block at which the upgrade should be  applied. The upgrade will be applied at the given relay chain block. In contrast to  ","[",(0,r.kt)("inlineCode",{parentName:"p"},"FutureCodeUpgrades"),"]"," this code upgrade will be applied regardless the parachain making any  progress or not. "),(0,r.kt)("p",{parentName:"li"}," Ordered ascending by block number. "))),(0,r.kt)("h3",{id:"headsu32-optionbytes"},"heads(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<Bytes>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.paras.heads")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The head-data of every registered para. ")),(0,r.kt)("h3",{id:"mostrecentcontextu32-optionu32"},"mostRecentContext(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.paras.mostRecentContext")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The context (relay-chain block number) of the most recent parachain head. ")),(0,r.kt)("h3",{id:"parachains-vecu32"},"parachains(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.paras.parachains"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    All lease holding parachains. Ordered ascending by ",(0,r.kt)("inlineCode",{parentName:"p"},"ParaId"),". On demand parachains are not  included. "),(0,r.kt)("p",{parentName:"li"}," Consider using the ","[",(0,r.kt)("inlineCode",{parentName:"p"},"ParachainsCache"),"]"," type of modifying. "))),(0,r.kt)("h3",{id:"paralifecyclesu32-optionpolkadotruntimeparachainsparasparalifecycle"},"paraLifecycles(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PolkadotRuntimeParachainsParasParaLifecycle>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.paras.paraLifecycles")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The current lifecycle of a all known Para IDs. ")),(0,r.kt)("h3",{id:"pastcodehashu32u32-optionh256"},"pastCodeHash(",(0,r.kt)("inlineCode",{parentName:"h3"},"(u32,u32)"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<H256>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.paras.pastCodeHash"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Actual past code hash, indicated by the para id as well as the block number at which it  became outdated. "),(0,r.kt)("p",{parentName:"li"}," Corresponding code can be retrieved with ","[",(0,r.kt)("inlineCode",{parentName:"p"},"CodeByHash"),"]",". "))),(0,r.kt)("h3",{id:"pastcodemetau32-polkadotruntimeparachainsparasparapastcodemeta"},"pastCodeMeta(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"PolkadotRuntimeParachainsParasParaPastCodeMeta")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.paras.pastCodeMeta")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Past code of parachains. The parachains themselves may not be registered anymore,  but we also keep their code on-chain for the same amount of time as outdated code  to keep it available for approval checkers. ")),(0,r.kt)("h3",{id:"pastcodepruning-vecu32u32"},"pastCodePruning(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<(u32,u32)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.paras.pastCodePruning")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Which paras have past code that needs pruning and the relay-chain block at which the code  was replaced. Note that this is the actual height of the included block, not the expected  height at which the code upgrade would be applied, although they may be equal.  This is to ensure the entire acceptance period is covered, not an offset acceptance period  starting from the time at which the parachain perceives a code upgrade as having occurred.  Multiple entries for a single para are permitted. Ordered ascending by block number. ")),(0,r.kt)("h3",{id:"pvfactivevotelist-vech256"},"pvfActiveVoteList(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<H256>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.paras.pvfActiveVoteList")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The list of all currently active PVF votes. Auxiliary to ",(0,r.kt)("inlineCode",{parentName:"li"},"PvfActiveVoteMap"),". ")),(0,r.kt)("h3",{id:"pvfactivevotemaph256-optionpolkadotruntimeparachainsparaspvfcheckactivevotestate"},"pvfActiveVoteMap(",(0,r.kt)("inlineCode",{parentName:"h3"},"H256"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PolkadotRuntimeParachainsParasPvfCheckActiveVoteState>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.paras.pvfActiveVoteMap"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    All currently active PVF pre-checking votes. "),(0,r.kt)("p",{parentName:"li"}," Invariant: "),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"There are no PVF pre-checking votes that exists in list but not in the set and vice versa.")))),(0,r.kt)("h3",{id:"upcomingparasgenesisu32-optionpolkadotruntimeparachainsparasparagenesisargs"},"upcomingParasGenesis(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PolkadotRuntimeParachainsParasParaGenesisArgs>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.paras.upcomingParasGenesis"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Upcoming paras instantiation arguments. "),(0,r.kt)("p",{parentName:"li"}," NOTE that after PVF pre-checking is enabled the para genesis arg will have it's code set  to empty. Instead, the code will be saved into the storage right away via ",(0,r.kt)("inlineCode",{parentName:"p"},"CodeByHash"),". "))),(0,r.kt)("h3",{id:"upcomingupgrades-vecu32u32"},"upcomingUpgrades(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<(u32,u32)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.paras.upcomingUpgrades"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The list of upcoming code upgrades. "),(0,r.kt)("p",{parentName:"li"}," Each item is a pair of which para performs a code upgrade and at which relay-chain block it  is expected at. "),(0,r.kt)("p",{parentName:"li"}," Ordered ascending by block number. "))),(0,r.kt)("h3",{id:"upgradecooldowns-vecu32u32"},"upgradeCooldowns(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<(u32,u32)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.paras.upgradeCooldowns"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The list of parachains that are awaiting for their upgrade restriction to cooldown. "),(0,r.kt)("p",{parentName:"li"}," Ordered ascending by block number. "))),(0,r.kt)("h3",{id:"upgradegoaheadsignalu32-optionpolkadotprimitivesv8upgradegoahead"},"upgradeGoAheadSignal(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PolkadotPrimitivesV8UpgradeGoAhead>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.paras.upgradeGoAheadSignal"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    This is used by the relay-chain to communicate to a parachain a go-ahead with in the upgrade  procedure. "),(0,r.kt)("p",{parentName:"li"}," This value is absent when there are no upgrades scheduled or during the time the relay chain  performs the checks. It is set at the first relay-chain block when the corresponding  parachain can switch its upgrade function. As soon as the parachain's block is included, the  value gets reset to ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),". "),(0,r.kt)("p",{parentName:"li"}," NOTE that this field is used by parachains via merkle storage proofs, therefore changing  the format will require migration of parachains. "))),(0,r.kt)("h3",{id:"upgraderestrictionsignalu32-optionpolkadotprimitivesv8upgraderestriction"},"upgradeRestrictionSignal(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PolkadotPrimitivesV8UpgradeRestriction>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.paras.upgradeRestrictionSignal"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    This is used by the relay-chain to communicate that there are restrictions for performing  an upgrade for this parachain. "),(0,r.kt)("p",{parentName:"li"}," This may be a because the parachain waits for the upgrade cooldown to expire. Another  potential use case is when we want to perform some maintenance (such as storage migration)  we could restrict upgrades to make the process simpler. "),(0,r.kt)("p",{parentName:"li"}," NOTE that this field is used by parachains via merkle storage proofs, therefore changing  the format will require migration of parachains. "))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"parascheduler"},"paraScheduler"),(0,r.kt)("h3",{id:"claimqueue-btreemapu32-vecpolkadotruntimeparachainsschedulercommonassignment"},"claimQueue(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"BTreeMap<u32, Vec<PolkadotRuntimeParachainsSchedulerCommonAssignment>>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.paraScheduler.claimQueue")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    One entry for each availability core. The ",(0,r.kt)("inlineCode",{parentName:"li"},"VecDeque")," represents the assignments to be  scheduled on that core. ")),(0,r.kt)("h3",{id:"sessionstartblock-u32"},"sessionStartBlock(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.paraScheduler.sessionStartBlock"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The block number where the session start occurred. Used to track how many group rotations  have occurred. "),(0,r.kt)("p",{parentName:"li"}," Note that in the context of parachains modules the session change is signaled during  the block and enacted at the end of the block (at the finalization stage, to be exact).  Thus for all intents and purposes the effect of the session change is observed at the  block following the session change, block number of which we save in this storage value. "))),(0,r.kt)("h3",{id:"validatorgroups-vecvecu32"},"validatorGroups(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<Vec<u32>>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.paraScheduler.validatorGroups"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    All the validator groups. One for each core. Indices are into ",(0,r.kt)("inlineCode",{parentName:"p"},"ActiveValidators")," - not the  broader set of Polkadot validators, but instead just the subset used for parachains during  this session. "),(0,r.kt)("p",{parentName:"li"}," Bound: The number of cores is the sum of the numbers of parachains and parathread  multiplexers. Reasonably, 100-1000. The dominant factor is the number of validators: safe  upper bound at 10k. "))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"parasdisputes"},"parasDisputes"),(0,r.kt)("h3",{id:"backersondisputesu32-h256-optionbtreesetu32"},"backersOnDisputes(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32, H256"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<BTreeSet<u32>>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.parasDisputes.backersOnDisputes")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Backing votes stored for each dispute.  This storage is used for slashing. ")),(0,r.kt)("h3",{id:"disputesu32-h256-optionpolkadotprimitivesv8disputestate"},"disputes(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32, H256"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PolkadotPrimitivesV8DisputeState>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.parasDisputes.disputes")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    All ongoing or concluded disputes for the last several sessions. ")),(0,r.kt)("h3",{id:"frozen-optionu32"},"frozen(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.parasDisputes.frozen")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Whether the chain is frozen. Starts as ",(0,r.kt)("inlineCode",{parentName:"li"},"None"),". When this is ",(0,r.kt)("inlineCode",{parentName:"li"},"Some"),",  the chain will not accept any new parachain blocks for backing or inclusion,  and its value indicates the last valid block number in the chain.  It can only be set back to ",(0,r.kt)("inlineCode",{parentName:"li"},"None")," by governance intervention. ")),(0,r.kt)("h3",{id:"includedu32-h256-optionu32"},"included(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32, H256"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.parasDisputes.included")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    All included blocks on the chain, as well as the block number in this chain that  should be reverted back to if the candidate is disputed and determined to be invalid. ")),(0,r.kt)("h3",{id:"lastprunedsession-optionu32"},"lastPrunedSession(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.parasDisputes.lastPrunedSession")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The last pruned session, if any. All data stored by this module  references sessions. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"parasessioninfo"},"paraSessionInfo"),(0,r.kt)("h3",{id:"accountkeysu32-optionvecaccountid32"},"accountKeys(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<Vec<AccountId32>>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.paraSessionInfo.accountKeys")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The validator account keys of the validators actively participating in parachain consensus. ")),(0,r.kt)("h3",{id:"assignmentkeysunsafe-vecpolkadotprimitivesv8assignmentapppublic"},"assignmentKeysUnsafe(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<PolkadotPrimitivesV8AssignmentAppPublic>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.paraSessionInfo.assignmentKeysUnsafe")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Assignment keys for the current session.  Note that this API is private due to it being prone to 'off-by-one' at session boundaries.  When in doubt, use ",(0,r.kt)("inlineCode",{parentName:"li"},"Sessions")," API instead. ")),(0,r.kt)("h3",{id:"earlieststoredsession-u32"},"earliestStoredSession(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.paraSessionInfo.earliestStoredSession")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The earliest session for which previous session info is stored. ")),(0,r.kt)("h3",{id:"sessionexecutorparamsu32-optionpolkadotprimitivesv8executorparams"},"sessionExecutorParams(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PolkadotPrimitivesV8ExecutorParams>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.paraSessionInfo.sessionExecutorParams")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Executor parameter set for a given session index ")),(0,r.kt)("h3",{id:"sessionsu32-optionpolkadotprimitivesv8sessioninfo"},"sessions(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PolkadotPrimitivesV8SessionInfo>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.paraSessionInfo.sessions")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Session information in a rolling window.  Should have an entry in range ",(0,r.kt)("inlineCode",{parentName:"li"},"EarliestStoredSession..=CurrentSessionIndex"),".  Does not have any entries before the session index in the first session change notification. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"parasshared"},"parasShared"),(0,r.kt)("h3",{id:"activevalidatorindices-vecu32"},"activeValidatorIndices(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.parasShared.activeValidatorIndices")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    All the validators actively participating in parachain consensus.  Indices are into the broader validator set. ")),(0,r.kt)("h3",{id:"activevalidatorkeys-vecpolkadotprimitivesv8validatorapppublic"},"activeValidatorKeys(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<PolkadotPrimitivesV8ValidatorAppPublic>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.parasShared.activeValidatorKeys")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The parachain attestation keys of the validators actively participating in parachain  consensus. This should be the same length as ",(0,r.kt)("inlineCode",{parentName:"li"},"ActiveValidatorIndices"),". ")),(0,r.kt)("h3",{id:"allowedrelayparents-polkadotruntimeparachainssharedallowedrelayparentstracker"},"allowedRelayParents(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"PolkadotRuntimeParachainsSharedAllowedRelayParentsTracker")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.parasShared.allowedRelayParents")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    All allowed relay-parents. ")),(0,r.kt)("h3",{id:"currentsessionindex-u32"},"currentSessionIndex(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.parasShared.currentSessionIndex")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The current session index. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"parasslashing"},"parasSlashing"),(0,r.kt)("h3",{id:"unappliedslashesu32-h256-optionpolkadotprimitivesv8slashingpendingslashes"},"unappliedSlashes(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32, H256"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PolkadotPrimitivesV8SlashingPendingSlashes>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.parasSlashing.unappliedSlashes")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Validators pending dispute slashes. ")),(0,r.kt)("h3",{id:"validatorsetcountsu32-optionu32"},"validatorSetCounts(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.parasSlashing.validatorSetCounts")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    ",(0,r.kt)("inlineCode",{parentName:"li"},"ValidatorSetCount")," per session. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"preimage"},"preimage"),(0,r.kt)("h3",{id:"preimageforh256u32-optionbytes"},"preimageFor(",(0,r.kt)("inlineCode",{parentName:"h3"},"(H256,u32)"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<Bytes>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.preimage.preimageFor"))),(0,r.kt)("h3",{id:"requeststatusforh256-optionpalletpreimagerequeststatus"},"requestStatusFor(",(0,r.kt)("inlineCode",{parentName:"h3"},"H256"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletPreimageRequestStatus>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.preimage.requestStatusFor")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The request status of a given hash. ")),(0,r.kt)("h3",{id:"statusforh256-optionpalletpreimageoldrequeststatus"},"statusFor(",(0,r.kt)("inlineCode",{parentName:"h3"},"H256"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletPreimageOldRequestStatus>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.preimage.statusFor")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The request status of a given hash. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"proxy"},"proxy"),(0,r.kt)("h3",{id:"announcementsaccountid32-vecpalletproxyannouncementu128"},"announcements(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"(Vec<PalletProxyAnnouncement>,u128)")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.proxy.announcements")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The announcements made by the proxy (key). ")),(0,r.kt)("h3",{id:"proxiesaccountid32-vecpalletproxyproxydefinitionu128"},"proxies(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"(Vec<PalletProxyProxyDefinition>,u128)")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.proxy.proxies")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The set of account proxies. Maps the account which has delegated to the accounts  which are being delegated to, together with the amount held on deposit. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"recovery"},"recovery"),(0,r.kt)("h3",{id:"activerecoveriesaccountid32-accountid32-optionpalletrecoveryactiverecovery"},"activeRecoveries(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32, AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletRecoveryActiveRecovery>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.recovery.activeRecoveries"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Active recovery attempts. "),(0,r.kt)("p",{parentName:"li"}," First account is the account to be recovered, and the second account  is the user trying to recover the account. "))),(0,r.kt)("h3",{id:"proxyaccountid32-optionaccountid32"},"proxy(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<AccountId32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.recovery.proxy"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The list of allowed proxy accounts. "),(0,r.kt)("p",{parentName:"li"}," Map from the user who can access it to the recovered account. "))),(0,r.kt)("h3",{id:"recoverableaccountid32-optionpalletrecoveryrecoveryconfig"},"recoverable(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletRecoveryRecoveryConfig>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.recovery.recoverable")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The set of recoverable accounts and their recovery configuration. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"referenda"},"referenda"),(0,r.kt)("h3",{id:"decidingcountu16-u32-1"},"decidingCount(",(0,r.kt)("inlineCode",{parentName:"h3"},"u16"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.referenda.decidingCount")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The number of referenda being decided currently. ")),(0,r.kt)("h3",{id:"metadataofu32-optionh256-1"},"metadataOf(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<H256>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.referenda.metadataOf"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The metadata is a general information concerning the referendum.  The ",(0,r.kt)("inlineCode",{parentName:"p"},"Hash")," refers to the preimage of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Preimages")," provider which can be a JSON  dump or IPFS hash of a JSON file. "),(0,r.kt)("p",{parentName:"li"}," Consider a garbage collection for a metadata of finished referendums to ",(0,r.kt)("inlineCode",{parentName:"p"},"unrequest")," (remove)  large preimages. "))),(0,r.kt)("h3",{id:"referendumcount-u32-1"},"referendumCount(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.referenda.referendumCount")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The next free referendum index, aka the number of referenda started so far. ")),(0,r.kt)("h3",{id:"referenduminfoforu32-optionpalletreferendareferenduminfoconvictionvotingtally"},"referendumInfoFor(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletReferendaReferendumInfoConvictionVotingTally>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.referenda.referendumInfoFor")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Information concerning any given referendum. ")),(0,r.kt)("h3",{id:"trackqueueu16-vecu32u128"},"trackQueue(",(0,r.kt)("inlineCode",{parentName:"h3"},"u16"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<(u32,u128)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.referenda.trackQueue"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The sorted list of referenda ready to be decided but not yet being decided, ordered by  conviction-weighted approvals. "),(0,r.kt)("p",{parentName:"li"}," This should be empty if ",(0,r.kt)("inlineCode",{parentName:"p"},"DecidingCount")," is less than ",(0,r.kt)("inlineCode",{parentName:"p"},"TrackInfo::max_deciding"),". "))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"registrar"},"registrar"),(0,r.kt)("h3",{id:"nextfreeparaid-u32"},"nextFreeParaId(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.registrar.nextFreeParaId")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The next free ",(0,r.kt)("inlineCode",{parentName:"li"},"ParaId"),". ")),(0,r.kt)("h3",{id:"parasu32-optionpolkadotruntimecommonparasregistrarparainfo"},"paras(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PolkadotRuntimeCommonParasRegistrarParaInfo>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.registrar.paras"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Amount held on deposit for each para and the original depositor. "),(0,r.kt)("p",{parentName:"li"}," The given account ID is responsible for registering the code and initial head data, but may  only do so if it isn't yet registered. (After that, it's up to governance to do so.) "))),(0,r.kt)("h3",{id:"pendingswapu32-optionu32"},"pendingSwap(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.registrar.pendingSwap")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Pending swap operations. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"scheduler"},"scheduler"),(0,r.kt)("h3",{id:"agendau32-vecoptionpalletschedulerscheduled"},"agenda(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<Option<PalletSchedulerScheduled>>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.scheduler.agenda")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Items to be executed, indexed by the block number that they should be executed on. ")),(0,r.kt)("h3",{id:"incompletesince-optionu32"},"incompleteSince(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.scheduler.incompleteSince")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Block number at which the agenda began incomplete execution. ")),(0,r.kt)("h3",{id:"lookupu832-optionu32u32"},"lookup(",(0,r.kt)("inlineCode",{parentName:"h3"},"[u8;32]"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<(u32,u32)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.scheduler.lookup"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Lookup from a name to the block number and index of the task. "),(0,r.kt)("p",{parentName:"li"}," For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4  identities. "))),(0,r.kt)("h3",{id:"retriesu32u32-optionpalletschedulerretryconfig"},"retries(",(0,r.kt)("inlineCode",{parentName:"h3"},"(u32,u32)"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletSchedulerRetryConfig>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.scheduler.retries")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Retry configurations for items to be executed, indexed by task address. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"session"},"session"),(0,r.kt)("h3",{id:"currentindex-u32"},"currentIndex(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.session.currentIndex")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Current index of the session. ")),(0,r.kt)("h3",{id:"disabledvalidators-vecu32perbill"},"disabledValidators(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<(u32,Perbill)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.session.disabledValidators"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Indices of disabled validators. "),(0,r.kt)("p",{parentName:"li"}," The vec is always kept sorted so that we can find whether a given validator is  disabled using binary search. It gets cleared when ",(0,r.kt)("inlineCode",{parentName:"p"},"on_session_ending")," returns  a new set of identities. "))),(0,r.kt)("h3",{id:"keyownerspcorecryptokeytypeidbytes-optionaccountid32"},"keyOwner(",(0,r.kt)("inlineCode",{parentName:"h3"},"(SpCoreCryptoKeyTypeId,Bytes)"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<AccountId32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.session.keyOwner")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The owner of a key. The key is the ",(0,r.kt)("inlineCode",{parentName:"li"},"KeyTypeId")," + the encoded key. ")),(0,r.kt)("h3",{id:"nextkeysaccountid32-optionstagingkusamaruntimesessionkeys"},"nextKeys(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<StagingKusamaRuntimeSessionKeys>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.session.nextKeys")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The next session keys for a validator. ")),(0,r.kt)("h3",{id:"queuedchanged-bool"},"queuedChanged(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"bool")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.session.queuedChanged")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    True if the underlying economic identities or weighting behind the validators  has changed in the queued validator set. ")),(0,r.kt)("h3",{id:"queuedkeys-vecaccountid32stagingkusamaruntimesessionkeys"},"queuedKeys(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<(AccountId32,StagingKusamaRuntimeSessionKeys)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.session.queuedKeys")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The queued keys for the next session. When the next session begins, these keys  will be used to determine the validator's session keys. ")),(0,r.kt)("h3",{id:"validators-vecaccountid32"},"validators(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<AccountId32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.session.validators")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The current set of validators. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"slots"},"slots"),(0,r.kt)("h3",{id:"leasesu32-vecoptionaccountid32u128"},"leases(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<Option<(AccountId32,u128)>>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.slots.leases"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Amounts held on deposit for each (possibly future) leased parachain. "),(0,r.kt)("p",{parentName:"li"}," The actual amount locked on its behalf by any account at any time is the maximum of the  second values of the items in this list whose first value is the account. "),(0,r.kt)("p",{parentName:"li"}," The first item in the list is the amount locked for the current Lease Period. Following  items are for the subsequent lease periods. "),(0,r.kt)("p",{parentName:"li"}," The default value (an empty list) implies that the parachain no longer exists (or never  existed) as far as this pallet is concerned. "),(0,r.kt)("p",{parentName:"li"}," If a parachain doesn't exist ",(0,r.kt)("em",{parentName:"p"},"yet")," but is scheduled to exist in the future, then it  will be left-padded with one or more ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),"s to denote the fact that nothing is held on  deposit for the non-existent chain currently, but is held at some point in the future. "),(0,r.kt)("p",{parentName:"li"}," It is illegal for a ",(0,r.kt)("inlineCode",{parentName:"p"},"None")," value to trail in the list. "))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"society"},"society"),(0,r.kt)("h3",{id:"bids-vecpalletsocietybid"},"bids(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<PalletSocietyBid>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.society.bids")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The current bids, stored ordered by the value of the bid. ")),(0,r.kt)("h3",{id:"candidatesaccountid32-optionpalletsocietycandidacy"},"candidates(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletSocietyCandidacy>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.society.candidates"))),(0,r.kt)("h3",{id:"challengeroundcount-u32"},"challengeRoundCount(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.society.challengeRoundCount")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The number of challenge rounds there have been. Used to identify stale DefenderVotes. ")),(0,r.kt)("h3",{id:"defendervotesu32-accountid32-optionpalletsocietyvote"},"defenderVotes(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32, AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletSocietyVote>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.society.defenderVotes")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Votes for the defender, keyed by challenge round. ")),(0,r.kt)("h3",{id:"defending-optionaccountid32accountid32palletsocietytally"},"defending(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<(AccountId32,AccountId32,PalletSocietyTally)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.society.defending")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The defending member currently being challenged, along with a running tally of votes. ")),(0,r.kt)("h3",{id:"founder-optionaccountid32"},"founder(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<AccountId32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.society.founder")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The first member. ")),(0,r.kt)("h3",{id:"head-optionaccountid32"},"head(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<AccountId32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.society.head")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The most primary from the most recently approved rank 0 members in the society. ")),(0,r.kt)("h3",{id:"memberbyindexu32-optionaccountid32"},"memberByIndex(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<AccountId32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.society.memberByIndex")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The current items in ",(0,r.kt)("inlineCode",{parentName:"li"},"Members")," keyed by their unique index. Keys are densely populated  ",(0,r.kt)("inlineCode",{parentName:"li"},"0..MemberCount")," (does not include ",(0,r.kt)("inlineCode",{parentName:"li"},"MemberCount"),"). ")),(0,r.kt)("h3",{id:"membercount-u32"},"memberCount(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.society.memberCount")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The number of items in ",(0,r.kt)("inlineCode",{parentName:"li"},"Members")," currently. (Doesn't include ",(0,r.kt)("inlineCode",{parentName:"li"},"SuspendedMembers"),".) ")),(0,r.kt)("h3",{id:"membersaccountid32-optionpalletsocietymemberrecord"},"members(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletSocietyMemberRecord>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.society.members")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The current members and their rank. Doesn't include ",(0,r.kt)("inlineCode",{parentName:"li"},"SuspendedMembers"),". ")),(0,r.kt)("h3",{id:"nexthead-optionpalletsocietyintakerecord"},"nextHead(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletSocietyIntakeRecord>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.society.nextHead")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    At the end of the claim period, this contains the most recently approved members (along with  their bid and round ID) who is from the most recent round with the lowest bid. They will  become the new ",(0,r.kt)("inlineCode",{parentName:"li"},"Head"),". ")),(0,r.kt)("h3",{id:"parameters-optionpalletsocietygroupparams"},"parameters(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletSocietyGroupParams>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.society.parameters")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The max number of members for the society at one time. ")),(0,r.kt)("h3",{id:"payoutsaccountid32-palletsocietypayoutrecord"},"payouts(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"PalletSocietyPayoutRecord")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.society.payouts")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Information regarding rank-0 payouts, past and future. ")),(0,r.kt)("h3",{id:"pot-u128"},"pot(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u128")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.society.pot")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Amount of our account balance that is specifically for the next round's bid(s). ")),(0,r.kt)("h3",{id:"roundcount-u32"},"roundCount(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.society.roundCount")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The number of rounds which have passed. ")),(0,r.kt)("h3",{id:"rules-optionh256"},"rules(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<H256>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.society.rules")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    A hash of the rules of this society concerning membership. Can only be set once and  only by the founder. ")),(0,r.kt)("h3",{id:"skeptic-optionaccountid32"},"skeptic(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<AccountId32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.society.skeptic")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The current skeptic. ")),(0,r.kt)("h3",{id:"suspendedmembersaccountid32-optionpalletsocietymemberrecord"},"suspendedMembers(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletSocietyMemberRecord>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.society.suspendedMembers")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The set of suspended members, with their old membership record. ")),(0,r.kt)("h3",{id:"voteclearcursoraccountid32-optionbytes"},"voteClearCursor(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<Bytes>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.society.voteClearCursor")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Clear-cursor for Vote, map from Candidate -> (Maybe) Cursor. ")),(0,r.kt)("h3",{id:"votesaccountid32-accountid32-optionpalletsocietyvote"},"votes(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32, AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletSocietyVote>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.society.votes")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Double map from Candidate -> Voter -> (Maybe) Vote. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"staking"},"staking"),(0,r.kt)("h3",{id:"activeera-optionpalletstakingactiveerainfo"},"activeEra(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletStakingActiveEraInfo>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.staking.activeEra"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The active era information, it holds index and start. "),(0,r.kt)("p",{parentName:"li"}," The active era is the era being currently rewarded. Validator set of this era must be  equal to ","[",(0,r.kt)("inlineCode",{parentName:"p"},"SessionInterface::validators"),"]",". "))),(0,r.kt)("h3",{id:"bondedaccountid32-optionaccountid32"},"bonded(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<AccountId32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.staking.bonded"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),':    Map from all locked "stash" accounts to the controller account. '),(0,r.kt)("p",{parentName:"li"}," TWOX-NOTE: SAFE since ",(0,r.kt)("inlineCode",{parentName:"p"},"AccountId")," is a secure hash. "))),(0,r.kt)("h3",{id:"bondederas-vecu32u32"},"bondedEras(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<(u32,u32)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.staking.bondedEras"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    A mapping from still-bonded eras to the first session index of that era. "),(0,r.kt)("p",{parentName:"li"}," Must contains information for eras for the range:  ",(0,r.kt)("inlineCode",{parentName:"p"},"[active_era - bounding_duration; active_era]")," "))),(0,r.kt)("h3",{id:"canceledslashpayout-u128"},"canceledSlashPayout(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u128")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.staking.canceledSlashPayout")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The amount of currency given to reporters of a slash event which was  canceled by extraordinary circumstances (e.g. governance). ")),(0,r.kt)("h3",{id:"chillthreshold-optionpercent"},"chillThreshold(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<Percent>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.staking.chillThreshold")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The threshold for when users can start calling ",(0,r.kt)("inlineCode",{parentName:"li"},"chill_other")," for other validators /  nominators. The threshold is compared to the actual number of validators / nominators  (",(0,r.kt)("inlineCode",{parentName:"li"},"CountFor*"),") in the system compared to the configured max (",(0,r.kt)("inlineCode",{parentName:"li"},"Max*Count"),"). ")),(0,r.kt)("h3",{id:"claimedrewardsu32-accountid32-vecu32"},"claimedRewards(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32, AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.staking.claimedRewards"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    History of claimed paged rewards by era and validator. "),(0,r.kt)("p",{parentName:"li"}," This is keyed by era and validator stash which maps to the set of page indexes which have  been claimed. "),(0,r.kt)("p",{parentName:"li"}," It is removed after ","[",(0,r.kt)("inlineCode",{parentName:"p"},"Config::HistoryDepth"),"]"," eras. "))),(0,r.kt)("h3",{id:"counterfornominators-u32"},"counterForNominators(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.staking.counterForNominators")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Counter for the related counted storage map ")),(0,r.kt)("h3",{id:"counterforvalidators-u32"},"counterForValidators(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.staking.counterForValidators")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Counter for the related counted storage map ")),(0,r.kt)("h3",{id:"counterforvirtualstakers-u32"},"counterForVirtualStakers(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.staking.counterForVirtualStakers")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Counter for the related counted storage map ")),(0,r.kt)("h3",{id:"currentera-optionu32"},"currentEra(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.staking.currentEra"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The current era index. "),(0,r.kt)("p",{parentName:"li"}," This is the latest planned era, depending on how the Session pallet queues the validator  set, it might be active or not. "))),(0,r.kt)("h3",{id:"currentplannedsession-u32"},"currentPlannedSession(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.staking.currentPlannedSession"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The last planned session scheduled by the session pallet. "),(0,r.kt)("p",{parentName:"li"}," This is basically in sync with the call to ","[",(0,r.kt)("inlineCode",{parentName:"p"},"pallet_session::SessionManager::new_session"),"]",". "))),(0,r.kt)("h3",{id:"erasrewardpointsu32-palletstakingerarewardpoints"},"erasRewardPoints(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"PalletStakingEraRewardPoints")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.staking.erasRewardPoints")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Rewards for the last ","[",(0,r.kt)("inlineCode",{parentName:"li"},"Config::HistoryDepth"),"]"," eras.  If reward hasn't been set or has been removed then 0 reward is returned. ")),(0,r.kt)("h3",{id:"erasstakersu32-accountid32-spstakingexposure"},"erasStakers(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32, AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"SpStakingExposure")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.staking.erasStakers"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Exposure of validator at era. "),(0,r.kt)("p",{parentName:"li"}," This is keyed first by the era index to allow bulk deletion and then the stash account. "),(0,r.kt)("p",{parentName:"li"}," Is it removed after ","[",(0,r.kt)("inlineCode",{parentName:"p"},"Config::HistoryDepth"),"]"," eras.  If stakers hasn't been set or has been removed then empty exposure is returned. "),(0,r.kt)("p",{parentName:"li"}," Note: Deprecated since v14. Use ",(0,r.kt)("inlineCode",{parentName:"p"},"EraInfo")," instead to work with exposures. "))),(0,r.kt)("h3",{id:"erasstakersclippedu32-accountid32-spstakingexposure"},"erasStakersClipped(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32, AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"SpStakingExposure")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.staking.erasStakersClipped"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Clipped Exposure of validator at era. "),(0,r.kt)("p",{parentName:"li"}," Note: This is deprecated, should be used as read-only and will be removed in the future.  New ",(0,r.kt)("inlineCode",{parentName:"p"},"Exposure"),"s are stored in a paged manner in ",(0,r.kt)("inlineCode",{parentName:"p"},"ErasStakersPaged")," instead. "),(0,r.kt)("p",{parentName:"li"}," This is similar to ","[",(0,r.kt)("inlineCode",{parentName:"p"},"ErasStakers"),"]"," but number of nominators exposed is reduced to the  ",(0,r.kt)("inlineCode",{parentName:"p"},"T::MaxExposurePageSize")," biggest stakers.  (Note: the field ",(0,r.kt)("inlineCode",{parentName:"p"},"total")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"own")," of the exposure remains unchanged).  This is used to limit the i/o cost for the nominator payout. "),(0,r.kt)("p",{parentName:"li"}," This is keyed fist by the era index to allow bulk deletion and then the stash account. "),(0,r.kt)("p",{parentName:"li"}," It is removed after ","[",(0,r.kt)("inlineCode",{parentName:"p"},"Config::HistoryDepth"),"]"," eras.  If stakers hasn't been set or has been removed then empty exposure is returned. "),(0,r.kt)("p",{parentName:"li"}," Note: Deprecated since v14. Use ",(0,r.kt)("inlineCode",{parentName:"p"},"EraInfo")," instead to work with exposures. "))),(0,r.kt)("h3",{id:"erasstakersoverviewu32-accountid32-optionspstakingpagedexposuremetadata"},"erasStakersOverview(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32, AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<SpStakingPagedExposureMetadata>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.staking.erasStakersOverview"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Summary of validator exposure at a given era. "),(0,r.kt)("p",{parentName:"li"}," This contains the total stake in support of the validator and their own stake. In addition,  it can also be used to get the number of nominators backing this validator and the number of  exposure pages they are divided into. The page count is useful to determine the number of  pages of rewards that needs to be claimed. "),(0,r.kt)("p",{parentName:"li"}," This is keyed first by the era index to allow bulk deletion and then the stash account.  Should only be accessed through ",(0,r.kt)("inlineCode",{parentName:"p"},"EraInfo"),". "),(0,r.kt)("p",{parentName:"li"}," Is it removed after ","[",(0,r.kt)("inlineCode",{parentName:"p"},"Config::HistoryDepth"),"]"," eras.  If stakers hasn't been set or has been removed then empty overview is returned. "))),(0,r.kt)("h3",{id:"erasstakerspagedu32-accountid32-u32-optionspstakingexposurepage"},"erasStakersPaged(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32, AccountId32, u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<SpStakingExposurePage>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.staking.erasStakersPaged"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Paginated exposure of a validator at given era. "),(0,r.kt)("p",{parentName:"li"}," This is keyed first by the era index to allow bulk deletion, then stash account and finally  the page. Should only be accessed through ",(0,r.kt)("inlineCode",{parentName:"p"},"EraInfo"),". "),(0,r.kt)("p",{parentName:"li"}," This is cleared after ","[",(0,r.kt)("inlineCode",{parentName:"p"},"Config::HistoryDepth"),"]"," eras. "))),(0,r.kt)("h3",{id:"erasstartsessionindexu32-optionu32"},"erasStartSessionIndex(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.staking.erasStartSessionIndex"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The session index at which the era start for the last ","[",(0,r.kt)("inlineCode",{parentName:"p"},"Config::HistoryDepth"),"]"," eras. "),(0,r.kt)("p",{parentName:"li"}," Note: This tracks the starting session (i.e. session index when era start being active)  for the eras in ",(0,r.kt)("inlineCode",{parentName:"p"},"[CurrentEra - HISTORY_DEPTH, CurrentEra]"),". "))),(0,r.kt)("h3",{id:"erastotalstakeu32-u128"},"erasTotalStake(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u128")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.staking.erasTotalStake")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The total amount staked for the last ","[",(0,r.kt)("inlineCode",{parentName:"li"},"Config::HistoryDepth"),"]"," eras.  If total hasn't been set or has been removed then 0 stake is returned. ")),(0,r.kt)("h3",{id:"erasvalidatorprefsu32-accountid32-palletstakingvalidatorprefs"},"erasValidatorPrefs(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32, AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"PalletStakingValidatorPrefs")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.staking.erasValidatorPrefs"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"ErasStakers"),", this holds the preferences of validators. "),(0,r.kt)("p",{parentName:"li"}," This is keyed first by the era index to allow bulk deletion and then the stash account. "),(0,r.kt)("p",{parentName:"li"}," Is it removed after ","[",(0,r.kt)("inlineCode",{parentName:"p"},"Config::HistoryDepth"),"]"," eras. "))),(0,r.kt)("h3",{id:"erasvalidatorrewardu32-optionu128"},"erasValidatorReward(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u128>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.staking.erasValidatorReward"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The total validator era payout for the last ","[",(0,r.kt)("inlineCode",{parentName:"p"},"Config::HistoryDepth"),"]"," eras. "),(0,r.kt)("p",{parentName:"li"}," Eras that haven't finished yet or has been removed doesn't have reward. "))),(0,r.kt)("h3",{id:"forceera-palletstakingforcing"},"forceEra(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"PalletStakingForcing")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.staking.forceEra")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Mode of era forcing. ")),(0,r.kt)("h3",{id:"invulnerables-vecaccountid32"},"invulnerables(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<AccountId32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.staking.invulnerables")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Any validators that may never be slashed or forcibly kicked. It's a Vec since they're  easy to initialize and the performance hit is minimal (we expect no more than four  invulnerables) and restricted to testnets. ")),(0,r.kt)("h3",{id:"ledgeraccountid32-optionpalletstakingstakingledger"},"ledger(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletStakingStakingLedger>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.staking.ledger"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),':    Map from all (unlocked) "controller" accounts to the info regarding the staking. '),(0,r.kt)("p",{parentName:"li"}," Note: All the reads and mutations to this storage ",(0,r.kt)("em",{parentName:"p"},"MUST")," be done through the methods exposed  by ","[",(0,r.kt)("inlineCode",{parentName:"p"},"StakingLedger"),"]"," to ensure data and lock consistency. "))),(0,r.kt)("h3",{id:"maxnominatorscount-optionu32"},"maxNominatorsCount(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.staking.maxNominatorsCount"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The maximum nominator count before we stop allowing new validators to join. "),(0,r.kt)("p",{parentName:"li"}," When this value is not set, no limits are enforced. "))),(0,r.kt)("h3",{id:"maxstakedrewards-optionpercent"},"maxStakedRewards(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<Percent>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.staking.maxStakedRewards")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Maximum staked rewards, i.e. the percentage of the era inflation that  is used for stake rewards.  See ",(0,r.kt)("a",{parentName:"li",href:"./index.html#era-payout"},"Era payout"),". ")),(0,r.kt)("h3",{id:"maxvalidatorscount-optionu32"},"maxValidatorsCount(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.staking.maxValidatorsCount"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The maximum validator count before we stop allowing new validators to join. "),(0,r.kt)("p",{parentName:"li"}," When this value is not set, no limits are enforced. "))),(0,r.kt)("h3",{id:"mincommission-perbill"},"minCommission(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Perbill")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.staking.minCommission"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The minimum amount of commission that validators can set. "),(0,r.kt)("p",{parentName:"li"}," If set to ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),", no limit exists. "))),(0,r.kt)("h3",{id:"minimumactivestake-u128"},"minimumActiveStake(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u128")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.staking.minimumActiveStake")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The minimum active nominator stake of the last successful election. ")),(0,r.kt)("h3",{id:"minimumvalidatorcount-u32"},"minimumValidatorCount(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.staking.minimumValidatorCount")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Minimum number of staking participants before emergency conditions are imposed. ")),(0,r.kt)("h3",{id:"minnominatorbond-u128"},"minNominatorBond(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u128")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.staking.minNominatorBond")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The minimum active bond to become and maintain the role of a nominator. ")),(0,r.kt)("h3",{id:"minvalidatorbond-u128"},"minValidatorBond(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u128")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.staking.minValidatorBond")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The minimum active bond to become and maintain the role of a validator. ")),(0,r.kt)("h3",{id:"nominatorsaccountid32-optionpalletstakingnominations"},"nominators(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletStakingNominations>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.staking.nominators"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The map from nominator stash key to their nomination preferences, namely the validators that  they wish to support. "),(0,r.kt)("p",{parentName:"li"}," Note that the keys of this storage map might become non-decodable in case the  account's ","[",(0,r.kt)("inlineCode",{parentName:"p"},"NominationsQuota::MaxNominations"),"]"," configuration is decreased.  In this rare case, these nominators  are still existent in storage, their key is correct and retrievable (i.e. ",(0,r.kt)("inlineCode",{parentName:"p"},"contains_key"),"  indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable  nominators will effectively not-exist, until they re-submit their preferences such that it  is within the bounds of the newly set ",(0,r.kt)("inlineCode",{parentName:"p"},"Config::MaxNominations"),". "),(0,r.kt)("p",{parentName:"li"}," This implies that ",(0,r.kt)("inlineCode",{parentName:"p"},"::iter_keys().count()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"::iter().count()")," might return different  values for this map. Moreover, the main ",(0,r.kt)("inlineCode",{parentName:"p"},"::count()")," is aligned with the former, namely the  number of keys that exist. "),(0,r.kt)("p",{parentName:"li"}," Lastly, if any of the nominators become non-decodable, they can be chilled immediately via  ","[",(0,r.kt)("inlineCode",{parentName:"p"},"Call::chill_other"),"]"," dispatchable by anyone. "),(0,r.kt)("p",{parentName:"li"}," TWOX-NOTE: SAFE since ",(0,r.kt)("inlineCode",{parentName:"p"},"AccountId")," is a secure hash. "))),(0,r.kt)("h3",{id:"nominatorslashinerau32-accountid32-optionu128"},"nominatorSlashInEra(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32, AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u128>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.staking.nominatorSlashInEra")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    All slashing events on nominators, mapped by era to the highest slash value of the era. ")),(0,r.kt)("h3",{id:"payeeaccountid32-optionpalletstakingrewarddestination"},"payee(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletStakingRewardDestination>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.staking.payee"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Where the reward payment should be made. Keyed by stash. "),(0,r.kt)("p",{parentName:"li"}," TWOX-NOTE: SAFE since ",(0,r.kt)("inlineCode",{parentName:"p"},"AccountId")," is a secure hash. "))),(0,r.kt)("h3",{id:"slashingspansaccountid32-optionpalletstakingslashingslashingspans"},"slashingSpans(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletStakingSlashingSlashingSpans>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.staking.slashingSpans")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Slashing spans for stash accounts. ")),(0,r.kt)("h3",{id:"slashrewardfraction-perbill"},"slashRewardFraction(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Perbill")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.staking.slashRewardFraction"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The percentage of the slash that is distributed to reporters. "),(0,r.kt)("p",{parentName:"li"}," The rest of the slashed value is handled by the ",(0,r.kt)("inlineCode",{parentName:"p"},"Slash"),". "))),(0,r.kt)("h3",{id:"spanslashaccountid32u32-palletstakingslashingspanrecord"},"spanSlash(",(0,r.kt)("inlineCode",{parentName:"h3"},"(AccountId32,u32)"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"PalletStakingSlashingSpanRecord")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.staking.spanSlash")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Records information about the maximum slash of a stash within a slashing span,  as well as how much reward has been paid out. ")),(0,r.kt)("h3",{id:"unappliedslashesu32-vecpalletstakingunappliedslash"},"unappliedSlashes(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<PalletStakingUnappliedSlash>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.staking.unappliedSlashes")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    All unapplied slashes that are queued for later. ")),(0,r.kt)("h3",{id:"validatorcount-u32"},"validatorCount(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.staking.validatorCount")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The ideal number of active validators. ")),(0,r.kt)("h3",{id:"validatorsaccountid32-palletstakingvalidatorprefs"},"validators(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"PalletStakingValidatorPrefs")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.staking.validators"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The map from (wannabe) validator stash key to the preferences of that validator. "),(0,r.kt)("p",{parentName:"li"}," TWOX-NOTE: SAFE since ",(0,r.kt)("inlineCode",{parentName:"p"},"AccountId")," is a secure hash. "))),(0,r.kt)("h3",{id:"validatorslashinerau32-accountid32-optionperbillu128"},"validatorSlashInEra(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32, AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<(Perbill,u128)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.staking.validatorSlashInEra")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    All slashing events on validators, mapped by era to the highest slash proportion  and slash value of the era. ")),(0,r.kt)("h3",{id:"virtualstakersaccountid32-optionnull"},"virtualStakers(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<Null>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.staking.virtualStakers"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Stakers whose funds are managed by other pallets. "),(0,r.kt)("p",{parentName:"li"}," This pallet does not apply any locks on them, therefore they are only virtually bonded. They  are expected to be keyless accounts and hence should not be allowed to mutate their ledger  directly via this pallet. Instead, these accounts are managed by other pallets and accessed  via low level apis. We keep track of them to do minimal integrity checks. "))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"substrate"},"substrate"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"These are well-known keys that are always available to the runtime implementation of any Substrate-based network.")),(0,r.kt)("h3",{id:"changestrieconfig-u32"},"changesTrieConfig(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.substrate.changesTrieConfig")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Changes trie configuration is stored under this key. ")),(0,r.kt)("h3",{id:"childstoragekeyprefix-u32"},"childStorageKeyPrefix(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.substrate.childStorageKeyPrefix")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Prefix of child storage keys. ")),(0,r.kt)("h3",{id:"code-bytes"},"code(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Bytes")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.substrate.code")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Wasm code of the runtime. ")),(0,r.kt)("h3",{id:"defaultchildstoragekeyprefix-u32"},"defaultChildStorageKeyPrefix(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.substrate.defaultChildStorageKeyPrefix")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Prefix of the default child storage keys in the top trie. ")),(0,r.kt)("h3",{id:"extrinsicindex-u32"},"extrinsicIndex(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.substrate.extrinsicIndex")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Current extrinsic index (u32) is stored under this key. ")),(0,r.kt)("h3",{id:"heappages-u64"},"heapPages(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u64")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.substrate.heapPages")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Number of wasm linear memory pages required for execution of the runtime. ")),(0,r.kt)("h3",{id:"intrablockentropy-u832"},"intrablockEntropy(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"[u8;32]")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.substrate.intrablockEntropy")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Current intra-block entropy (a universally unique ",(0,r.kt)("inlineCode",{parentName:"li"},"[u8; 32]")," value) is stored here. ")),(0,r.kt)("h3",{id:"storageversionstoragekeypostfix-u16"},"storageVersionStorageKeyPostfix(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u16")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.substrate.storageVersionStorageKeyPostfix")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The storage key postfix that is used to store the ","[",(0,r.kt)("inlineCode",{parentName:"li"},"StorageVersion"),"]"," per pallet. ")),(0,r.kt)("h3",{id:"transactionlevelkey-u32"},"transactionLevelKey(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.substrate.transactionLevelKey")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The key that holds the current number of active layers. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"system"},"system"),(0,r.kt)("h3",{id:"accountaccountid32-framesystemaccountinfo"},"account(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"FrameSystemAccountInfo")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.system.account")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The full account information for a particular account ID. ")),(0,r.kt)("h3",{id:"allextrinsicslen-optionu32"},"allExtrinsicsLen(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.system.allExtrinsicsLen")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Total length (in bytes) for all extrinsics put together, for the current block. ")),(0,r.kt)("h3",{id:"authorizedupgrade-optionframesystemcodeupgradeauthorization"},"authorizedUpgrade(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<FrameSystemCodeUpgradeAuthorization>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.system.authorizedUpgrade")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    ",(0,r.kt)("inlineCode",{parentName:"li"},"Some")," if a code upgrade has been authorized. ")),(0,r.kt)("h3",{id:"blockhashu32-h256"},"blockHash(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"H256")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.system.blockHash")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Map of block numbers to block hashes. ")),(0,r.kt)("h3",{id:"blockweight-framesupportdispatchperdispatchclassweight"},"blockWeight(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"FrameSupportDispatchPerDispatchClassWeight")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.system.blockWeight")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The current weight for the block. ")),(0,r.kt)("h3",{id:"digest-spruntimedigest"},"digest(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"SpRuntimeDigest")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.system.digest")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Digest of the current block, also part of the block header. ")),(0,r.kt)("h3",{id:"eventcount-u32"},"eventCount(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.system.eventCount")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The number of events in the ",(0,r.kt)("inlineCode",{parentName:"li"},"Events<T>")," list. ")),(0,r.kt)("h3",{id:"events-vecframesystemeventrecord"},"events(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<FrameSystemEventRecord>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.system.events"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Events deposited for the current block. "),(0,r.kt)("p",{parentName:"li"}," NOTE: The item is unbound and should therefore never be read on chain.  It could otherwise inflate the PoV size of a block. "),(0,r.kt)("p",{parentName:"li"}," Events have a large in-memory size. Box the events to not go out-of-memory  just in case someone still reads them from within the runtime. "))),(0,r.kt)("h3",{id:"eventtopicsh256-vecu32u32"},"eventTopics(",(0,r.kt)("inlineCode",{parentName:"h3"},"H256"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<(u32,u32)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.system.eventTopics"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Mapping between a topic (represented by T::Hash) and a vector of indexes  of events in the ",(0,r.kt)("inlineCode",{parentName:"p"},"<Events<T>>")," list. "),(0,r.kt)("p",{parentName:"li"}," All topic vectors have deterministic storage locations depending on the topic. This  allows light-clients to leverage the changes trie storage tracking mechanism and  in case of changes fetch the list of events of interest. "),(0,r.kt)("p",{parentName:"li"}," The value has the type ",(0,r.kt)("inlineCode",{parentName:"p"},"(BlockNumberFor<T>, EventIndex)")," because if we used only just  the ",(0,r.kt)("inlineCode",{parentName:"p"},"EventIndex")," then in case if the topic has the same contents on the next block  no notification will be triggered thus the event might be lost. "))),(0,r.kt)("h3",{id:"executionphase-optionframesystemphase"},"executionPhase(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<FrameSystemPhase>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.system.executionPhase")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The execution phase of the block. ")),(0,r.kt)("h3",{id:"extrinsiccount-optionu32"},"extrinsicCount(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.system.extrinsicCount")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Total extrinsics count for the current block. ")),(0,r.kt)("h3",{id:"extrinsicdatau32-bytes"},"extrinsicData(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Bytes")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.system.extrinsicData")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Extrinsics data for the current block (maps an extrinsic's index to its data). ")),(0,r.kt)("h3",{id:"extrinsicweightreclaimed-spweightsweightv2weight"},"extrinsicWeightReclaimed(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"SpWeightsWeightV2Weight")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.system.extrinsicWeightReclaimed"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The weight reclaimed for the extrinsic. "),(0,r.kt)("p",{parentName:"li"}," This information is available until the end of the extrinsic execution.  More precisely this information is removed in ",(0,r.kt)("inlineCode",{parentName:"p"},"note_applied_extrinsic"),". "),(0,r.kt)("p",{parentName:"li"}," Logic doing some post dispatch weight reduction must update this storage to avoid duplicate  reduction. "))),(0,r.kt)("h3",{id:"inherentsapplied-bool"},"inherentsApplied(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"bool")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.system.inherentsApplied")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Whether all inherents have been applied. ")),(0,r.kt)("h3",{id:"lastruntimeupgrade-optionframesystemlastruntimeupgradeinfo"},"lastRuntimeUpgrade(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<FrameSystemLastRuntimeUpgradeInfo>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.system.lastRuntimeUpgrade")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Stores the ",(0,r.kt)("inlineCode",{parentName:"li"},"spec_version")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"spec_name")," of when the last runtime upgrade happened. ")),(0,r.kt)("h3",{id:"number-u32"},"number(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.system.number")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The current block number being processed. Set by ",(0,r.kt)("inlineCode",{parentName:"li"},"execute_block"),". ")),(0,r.kt)("h3",{id:"parenthash-h256"},"parentHash(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"H256")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.system.parentHash")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Hash of the previous block. ")),(0,r.kt)("h3",{id:"upgradedtotriplerefcount-bool"},"upgradedToTripleRefCount(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"bool")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.system.upgradedToTripleRefCount")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    True if we have upgraded so that AccountInfo contains three types of ",(0,r.kt)("inlineCode",{parentName:"li"},"RefCount"),". False  (default) if not. ")),(0,r.kt)("h3",{id:"upgradedtou32refcount-bool"},"upgradedToU32RefCount(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"bool")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.system.upgradedToU32RefCount")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    True if we have upgraded so that ",(0,r.kt)("inlineCode",{parentName:"li"},"type RefCount")," is ",(0,r.kt)("inlineCode",{parentName:"li"},"u32"),". False (default) if not. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"timestamp"},"timestamp"),(0,r.kt)("h3",{id:"didupdate-bool"},"didUpdate(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"bool")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.timestamp.didUpdate"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Whether the timestamp has been updated in this block. "),(0,r.kt)("p",{parentName:"li"}," This value is updated to ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," upon successful submission of a timestamp by a node.  It is then checked at the end of each block execution in the ",(0,r.kt)("inlineCode",{parentName:"p"},"on_finalize")," hook. "))),(0,r.kt)("h3",{id:"now-u64"},"now(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u64")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.timestamp.now")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The current time for the current block. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"transactionpayment"},"transactionPayment"),(0,r.kt)("h3",{id:"nextfeemultiplier-u128"},"nextFeeMultiplier(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u128")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.transactionPayment.nextFeeMultiplier"))),(0,r.kt)("h3",{id:"storageversion-pallettransactionpaymentreleases"},"storageVersion(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"PalletTransactionPaymentReleases")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.transactionPayment.storageVersion"))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"treasury"},"treasury"),(0,r.kt)("h3",{id:"approvals-vecu32"},"approvals(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.treasury.approvals"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    DEPRECATED: associated with ",(0,r.kt)("inlineCode",{parentName:"p"},"spend_local")," call and will be removed in May 2025.  Refer to ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/polkadot-sdk/pull/5961"},"https://github.com/paritytech/polkadot-sdk/pull/5961")," for migration to ",(0,r.kt)("inlineCode",{parentName:"p"},"spend"),". "),(0,r.kt)("p",{parentName:"li"}," Proposal indices that have been approved but not yet awarded. "))),(0,r.kt)("h3",{id:"deactivated-u128"},"deactivated(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u128")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.treasury.deactivated")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The amount which has been reported as inactive to Currency. ")),(0,r.kt)("h3",{id:"lastspendperiod-optionu32"},"lastSpendPeriod(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.treasury.lastSpendPeriod")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The blocknumber for the last triggered spend period. ")),(0,r.kt)("h3",{id:"proposalcount-u32"},"proposalCount(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.treasury.proposalCount"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    DEPRECATED: associated with ",(0,r.kt)("inlineCode",{parentName:"p"},"spend_local")," call and will be removed in May 2025.  Refer to ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/polkadot-sdk/pull/5961"},"https://github.com/paritytech/polkadot-sdk/pull/5961")," for migration to ",(0,r.kt)("inlineCode",{parentName:"p"},"spend"),". "),(0,r.kt)("p",{parentName:"li"}," Number of proposals that have been made. "))),(0,r.kt)("h3",{id:"proposalsu32-optionpallettreasuryproposal"},"proposals(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletTreasuryProposal>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.treasury.proposals"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    DEPRECATED: associated with ",(0,r.kt)("inlineCode",{parentName:"p"},"spend_local")," call and will be removed in May 2025.  Refer to ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/polkadot-sdk/pull/5961"},"https://github.com/paritytech/polkadot-sdk/pull/5961")," for migration to ",(0,r.kt)("inlineCode",{parentName:"p"},"spend"),". "),(0,r.kt)("p",{parentName:"li"}," Proposals that have been made. "))),(0,r.kt)("h3",{id:"spendcount-u32"},"spendCount(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.treasury.spendCount")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The count of spends that have been made. ")),(0,r.kt)("h3",{id:"spendsu32-optionpallettreasuryspendstatus"},"spends(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletTreasurySpendStatus>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.treasury.spends")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Spends that have been approved and being processed. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"vesting"},"vesting"),(0,r.kt)("h3",{id:"storageversion-palletvestingreleases"},"storageVersion(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"PalletVestingReleases")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.vesting.storageVersion"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Storage version of the pallet. "),(0,r.kt)("p",{parentName:"li"}," New networks start with latest version, as determined by the genesis build. "))),(0,r.kt)("h3",{id:"vestingaccountid32-optionvecpalletvestingvestinginfo"},"vesting(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<Vec<PalletVestingVestingInfo>>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.vesting.vesting")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Information regarding the vesting of a given account. ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"voterlist"},"voterList"),(0,r.kt)("h3",{id:"counterforlistnodes-u32"},"counterForListNodes(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.voterList.counterForListNodes")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Counter for the related counted storage map ")),(0,r.kt)("h3",{id:"listbagsu64-optionpalletbagslistlistbag"},"listBags(",(0,r.kt)("inlineCode",{parentName:"h3"},"u64"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletBagsListListBag>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.voterList.listBags"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    A bag stored in storage. "),(0,r.kt)("p",{parentName:"li"}," Stores a ",(0,r.kt)("inlineCode",{parentName:"p"},"Bag")," struct, which stores head and tail pointers to itself. "))),(0,r.kt)("h3",{id:"listnodesaccountid32-optionpalletbagslistlistnode"},"listNodes(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletBagsListListNode>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.voterList.listNodes"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    A single node, within some bag. "),(0,r.kt)("p",{parentName:"li"}," Nodes store links forward and back within their respective bags. "))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"whitelist"},"whitelist"),(0,r.kt)("h3",{id:"whitelistedcallh256-optionnull"},"whitelistedCall(",(0,r.kt)("inlineCode",{parentName:"h3"},"H256"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<Null>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.whitelist.whitelistedCall"))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"xcmpallet"},"xcmPallet"),(0,r.kt)("h3",{id:"assettrapsh256-u32"},"assetTraps(",(0,r.kt)("inlineCode",{parentName:"h3"},"H256"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u32")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.xcmPallet.assetTraps"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    The existing asset traps. "),(0,r.kt)("p",{parentName:"li"}," Key is the blake2 256 hash of (origin, versioned ",(0,r.kt)("inlineCode",{parentName:"p"},"Assets"),") pair. Value is the number of  times this pair has been trapped (usually just 1 if it exists at all). "))),(0,r.kt)("h3",{id:"authorizedaliasesxcmversionedlocation-optionpalletxcmauthorizedaliasesentry"},"authorizedAliases(",(0,r.kt)("inlineCode",{parentName:"h3"},"XcmVersionedLocation"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletXcmAuthorizedAliasesEntry>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.xcmPallet.authorizedAliases")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Map of authorized aliasers of local origins. Each local location can authorize a list of  other locations to alias into it. Each aliaser is only valid until its inner ",(0,r.kt)("inlineCode",{parentName:"li"},"expiry"),"  block number. ")),(0,r.kt)("h3",{id:"currentmigration-optionpalletxcmversionmigrationstage"},"currentMigration(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletXcmVersionMigrationStage>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.xcmPallet.currentMigration")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The current migration's stage, if any. ")),(0,r.kt)("h3",{id:"lockedfungiblesaccountid32-optionvecu128xcmversionedlocation"},"lockedFungibles(",(0,r.kt)("inlineCode",{parentName:"h3"},"AccountId32"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<Vec<(u128,XcmVersionedLocation)>>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.xcmPallet.lockedFungibles")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Fungible assets which we know are locked on this chain. ")),(0,r.kt)("h3",{id:"queriesu64-optionpalletxcmquerystatus"},"queries(",(0,r.kt)("inlineCode",{parentName:"h3"},"u64"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletXcmQueryStatus>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.xcmPallet.queries")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The ongoing queries. ")),(0,r.kt)("h3",{id:"querycounter-u64"},"queryCounter(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"u64")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.xcmPallet.queryCounter")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The latest available query index. ")),(0,r.kt)("h3",{id:"recordedxcm-optionstagingxcmv5xcm"},"recordedXcm(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<StagingXcmV5Xcm>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.xcmPallet.recordedXcm"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    If ","[",(0,r.kt)("inlineCode",{parentName:"p"},"ShouldRecordXcm"),"]"," is set to true, then the last XCM program executed locally  will be stored here.  Runtime APIs can fetch the XCM that was executed by accessing this value. "),(0,r.kt)("p",{parentName:"li"}," Only relevant if this pallet is being used as the ","[",(0,r.kt)("inlineCode",{parentName:"p"},"xcm_executor::traits::RecordXcm"),"]","  implementation in the XCM executor configuration. "))),(0,r.kt)("h3",{id:"remotelockedfungiblesu32-accountid32-xcmversionedassetid-optionpalletxcmremotelockedfungiblerecord"},"remoteLockedFungibles(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32, AccountId32, XcmVersionedAssetId"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<PalletXcmRemoteLockedFungibleRecord>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.xcmPallet.remoteLockedFungibles")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Fungible assets which we know are locked on a remote chain. ")),(0,r.kt)("h3",{id:"safexcmversion-optionu32"},"safeXcmVersion(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.xcmPallet.safeXcmVersion")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Default version to encode XCM when latest version of destination is unknown. If ",(0,r.kt)("inlineCode",{parentName:"li"},"None"),",  then the destinations whose XCM version is unknown are considered unreachable. ")),(0,r.kt)("h3",{id:"shouldrecordxcm-bool"},"shouldRecordXcm(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"bool")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.xcmPallet.shouldRecordXcm"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"summary"),":    Whether or not incoming XCMs (both executed locally and received) should be recorded.  Only one XCM program will be recorded at a time.  This is meant to be used in runtime APIs, and it's advised it stays false  for all other use cases, so as to not degrade regular performance. "),(0,r.kt)("p",{parentName:"li"}," Only relevant if this pallet is being used as the ","[",(0,r.kt)("inlineCode",{parentName:"p"},"xcm_executor::traits::RecordXcm"),"]","  implementation in the XCM executor configuration. "))),(0,r.kt)("h3",{id:"supportedversionu32-xcmversionedlocation-optionu32"},"supportedVersion(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32, XcmVersionedLocation"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u32>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.xcmPallet.supportedVersion")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The Latest versions that we know various locations support. ")),(0,r.kt)("h3",{id:"versiondiscoveryqueue-vecxcmversionedlocationu32"},"versionDiscoveryQueue(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Vec<(XcmVersionedLocation,u32)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.xcmPallet.versionDiscoveryQueue")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Destinations whose latest XCM version we would like to know. Duplicates not allowed, and  the ",(0,r.kt)("inlineCode",{parentName:"li"},"u32")," counter is the number of times that a send to the destination has been attempted,  which is used as a prioritization. ")),(0,r.kt)("h3",{id:"versionnotifiersu32-xcmversionedlocation-optionu64"},"versionNotifiers(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32, XcmVersionedLocation"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<u64>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.xcmPallet.versionNotifiers")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    All locations that we have requested version notifications from. ")),(0,r.kt)("h3",{id:"versionnotifytargetsu32-xcmversionedlocation-optionu64spweightsweightv2weightu32"},"versionNotifyTargets(",(0,r.kt)("inlineCode",{parentName:"h3"},"u32, XcmVersionedLocation"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Option<(u64,SpWeightsWeightV2Weight,u32)>")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.xcmPallet.versionNotifyTargets")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    The target locations that are subscribed to our version changes, as well as the most recent  of our versions we informed them of. ")),(0,r.kt)("h3",{id:"xcmexecutionsuspended-bool"},"xcmExecutionSuspended(): ",(0,r.kt)("inlineCode",{parentName:"h3"},"bool")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"interface"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.xcmPallet.xcmExecutionSuspended")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"summary"),":    Global suspension state of the XCM executor.")))}k.isMDXComponent=!0}}]);