"use strict";(self.webpackChunkpolkadot_js=self.webpackChunkpolkadot_js||[]).push([[9316],{4137:function(e,t,a){a.d(t,{Zo:function(){return d},kt:function(){return m}});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},d=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(a),h=i,m=u["".concat(l,".").concat(h)]||u[h]||p[h]||r;return a?n.createElement(m,o(o({ref:t},d),{},{components:a})):n.createElement(m,o({ref:t},d))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},8809:function(e,t,a){a.r(t),a.d(t,{assets:function(){return d},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return u}});var n=a(7462),i=a(3366),r=(a(7294),a(4137)),o=["components"],s={title:"Basics & Metadata"},l=void 0,c={unversionedId:"api/start/basics",id:"api/start/basics",title:"Basics & Metadata",description:"One of the most important things to understand about the @polkadot/api is that most interfaces are actually generated automatically when it connects to a running node. This is quite a departure from other APIs in projects where the interfaces are static. While sounding quite scary, it actually is a powerful concept that exists in both Polkadot and Substrate chains, and allows the API to be used in environments where the chain is customized.",source:"@site/docs/api/start/basics.md",sourceDirName:"api/start",slug:"/api/start/basics",permalink:"/docs/api/start/basics",draft:!1,editUrl:"https://github.com/polkadot-js/docs/edit/master/docs/api/start/basics.md",tags:[],version:"current",frontMatter:{title:"Basics & Metadata"},sidebar:"reference",previous:{title:"Installation",permalink:"/docs/api/start/install"},next:{title:"Create an instance",permalink:"/docs/api/start/create"}},d={},u=[{value:"Metadata",id:"metadata",level:2},{value:"Types",id:"types",level:2},{value:"Chain Defaults",id:"chain-defaults",level:2},{value:"Let&#39;s do something!",id:"lets-do-something",level:2}],p={toc:u},h="wrapper";function m(e){var t=e.components,a=(0,i.Z)(e,o);return(0,r.kt)(h,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"One of the most important things to understand about the ",(0,r.kt)("inlineCode",{parentName:"p"},"@polkadot/api")," is that most interfaces are actually generated automatically when it connects to a running node. This is quite a departure from other APIs in projects where the interfaces are static. While sounding quite scary, it actually is a powerful concept that exists in both Polkadot and Substrate chains, and allows the API to be used in environments where the chain is customized."),(0,r.kt)("p",null,"To unpack this, we will start with the Metadata and explain what it actually provides, since it is critical for understanding how to interact with the API and any underlying chain."),(0,r.kt)("h2",{id:"metadata"},"Metadata"),(0,r.kt)("p",null,"When the API connects to a node, one of the first things it does is to retrieve the metadata and decorate the API based on the metadata information. The metadata effectively provides data in the form of ",(0,r.kt)("inlineCode",{parentName:"p"},"api.<type>.<module>.<section>")," that fits into one of the following categories -"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/substrate/constants"},"consts")," - All runtime constants, e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"api.consts.balances.existentialDeposit"),". These are not functions, rather accessing the endpoint immediately yields the result as defined."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/substrate/storage"},"query")," - All chain state, e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"api.query.system.account(<accountId>)"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/substrate/extrinsics"},"tx")," - All extrinsics, e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"api.tx.balances.transferKeepAlive(<accountId>, <value>)"),".")),(0,r.kt)("p",null,"Additionally the metadata also provides information on ",(0,r.kt)("a",{parentName:"p",href:"/docs/substrate/events"},"events"),", these are query-able via the ",(0,r.kt)("inlineCode",{parentName:"p"},"api.query.system.events()")," interface and also appear on transactions... both these cases are detailed later."),(0,r.kt)("p",null,"None of the information contained within the ",(0,r.kt)("inlineCode",{parentName:"p"},"api.{consts, query, tx}.<module>.<method>")," endpoints are hard coded in the API. Rather everything is fully decorated by what the metadata exposes and is therefore completely dynamic. This means that when you connect to different chains, the metadata and API decoration will change and the API interfaces will reflect what is available on the chain you are connected to."),(0,r.kt)("h2",{id:"types"},"Types"),(0,r.kt)("p",null,"The metadata defines the calls with all the type names used in the various interfaces. At the moment (this is undergoing investigations and could improve in future versions of metadata), this also means that the types between the API and the node need to be aligned. For instance, by default Substrate defines a ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockNumber")," type as a ",(0,r.kt)("inlineCode",{parentName:"p"},"u32")," and the API follows the Substrate defaults - if a chain has a different definition, the API needs to be aware of this so it can actually decode (and encode) the type."),(0,r.kt)("p",null,"At this point just be aware of it, we will touch on types, custom chains and their impacts in a later section."),(0,r.kt)("h2",{id:"chain-defaults"},"Chain Defaults"),(0,r.kt)("p",null,"In addition to the ",(0,r.kt)("inlineCode",{parentName:"p"},"api.[consts | query | tx]")," detailed above, the API, upon connecting to a chain, fills in some information and makes it available directly on the API interface. These include -"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"api.genesisHash")," - The genesisHash of the connected chain"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"api.runtimeMetadata")," - The metadata as retrieved from the chain"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"api.runtimeVersion")," - The chain runtime version (including spec/impl. versions and types)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"api.libraryInfo")," - The version of the API, i.e. ",(0,r.kt)("inlineCode",{parentName:"li"},"@polkadot/api v0.90.1"))),(0,r.kt)("h2",{id:"lets-do-something"},"Let's do something!"),(0,r.kt)("p",null,"Now that we have covered what the API actually exposes, it is time to ",(0,r.kt)("a",{parentName:"p",href:"/docs/api/start/create"},"dive in and actually use what we installed earlier"),"."))}m.isMDXComponent=!0}}]);